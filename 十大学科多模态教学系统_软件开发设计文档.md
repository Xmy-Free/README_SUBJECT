# ğŸ—ï¸ åå¤§å­¦ç§‘å¤šæ¨¡æ€æ•™å­¦èµ„æºåˆ¶ä½œç®¡ç†ç³»ç»Ÿ - è½¯ä»¶å¼€å‘è®¾è®¡æ–‡æ¡£

<div align="center">

![æ¶æ„ç‰ˆæœ¬](https://img.shields.io/badge/æ¶æ„ç‰ˆæœ¬-v1.0.0-00f7ff?style=for-the-badge&logo=architecture)
![è®¾è®¡æ¨¡å¼](https://img.shields.io/badge/è®¾è®¡æ¨¡å¼-å¾®æœåŠ¡%20%7C%20ç»„ä»¶åŒ–-ff00aa?style=for-the-badge&logo=design)
![æŠ€æœ¯æ ˆ](https://img.shields.io/badge/æŠ€æœ¯æ ˆ-ç°ä»£åŒ–å…¨æ ˆ-00ff88?style=for-the-badge&logo=tech)
![å¼€å‘è§„èŒƒ](https://img.shields.io/badge/å¼€å‘è§„èŒƒ-ä¼ä¸šçº§-orange?style=for-the-badge&logo=standard)

**ğŸŒŸ åŸºäºç°ä»£åŒ–æŠ€æœ¯æ ˆçš„é©å‘½æ€§æ•™è‚²å¹³å°æ¶æ„è®¾è®¡**

*é¡¹ç›®å¼€å‘ï¼š2025å¹´7æœˆç”± @æ˜Ÿæ¢¦æ¸¸Xmy ç‹¬ç«‹å¼€å‘*

---

### ğŸ“Š ç³»ç»ŸæŠ€æœ¯æ¦‚è§ˆ
ğŸ¯ **10å¤§å­¦ç§‘** | ğŸ—ï¸ **å¾®æœåŠ¡æ¶æ„** | ğŸ¤– **20+AIæ¨¡å‹** | ğŸ® **3Då¯è§†åŒ–** | ğŸ“± **å…¨å¹³å°æ”¯æŒ**

</div>

---

## ğŸ¯ ç³»ç»Ÿæ¶æ„è®¾è®¡

### ğŸ›ï¸ æ•´ä½“æ¶æ„è®¾è®¡ç†å¿µ

æœ¬ç³»ç»Ÿé‡‡ç”¨**ç°ä»£åŒ–å¾®æœåŠ¡æ¶æ„**ï¼Œç»“åˆ**ç»„ä»¶åŒ–è®¾è®¡æ¨¡å¼**å’Œ**é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)**ï¼Œæ„å»ºé«˜å†…èšã€ä½è€¦åˆçš„æ•™è‚²æŠ€æœ¯å¹³å°ã€‚ç³»ç»Ÿéµå¾ª**SOLIDåŸåˆ™**å’Œ**Clean Architecture**ç†å¿µï¼Œç¡®ä¿ä»£ç çš„å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§å’Œå¯æµ‹è¯•æ€§ã€‚

### ğŸ“Š ç³»ç»Ÿæ¶æ„å…¨æ™¯å›¾

```
ğŸŒŸ åå¤§å­¦ç§‘å¤šæ¨¡æ€æ•™å­¦ç³»ç»Ÿæ¶æ„
â”‚
â”œâ”€â”€ ğŸ¨ è¡¨ç°å±‚ (Presentation Layer) â”€â”€â”€â”€â”€â”€â”€ ç”¨æˆ·ç•Œé¢ä¸äº¤äº’
â”‚   â”œâ”€â”€ ğŸŒ Webå‰ç«¯åº”ç”¨ (SPA)
â”‚   â”‚   â”œâ”€â”€ Reactç»„ä»¶åº“ (åœ°ç†3Dåœ°å›¾)
â”‚   â”‚   â”œâ”€â”€ åŸç”ŸJavaScriptæ¨¡å— (å…¶ä»–å­¦ç§‘)
â”‚   â”‚   â””â”€â”€ PWAæ¸è¿›å¼åº”ç”¨
â”‚   â”œâ”€â”€ ğŸ“± ç§»åŠ¨ç«¯é€‚é…
â”‚   â””â”€â”€ ğŸ® 3Däº¤äº’ç•Œé¢
â”‚
â”œâ”€â”€ ğŸ”„ åº”ç”¨å±‚ (Application Layer) â”€â”€â”€â”€â”€â”€ ä¸šåŠ¡æµç¨‹ç¼–æ’
â”‚   â”œâ”€â”€ ğŸ“ å­¦ç§‘ä¸šåŠ¡æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ è®¡ç®—æœºå­¦ç§‘æœåŠ¡ (AIåŠ©æ‰‹ã€3Dç¡¬ä»¶)
â”‚   â”‚   â”œâ”€â”€ æ•°å­¦å­¦ç§‘æœåŠ¡ (å…¬å¼ç¼–è¾‘ã€3Då‡ ä½•)
â”‚   â”‚   â”œâ”€â”€ ç‰©ç†å­¦ç§‘æœåŠ¡ (ç‰©ç†æ¨¡æ‹Ÿã€å®éªŒ)
â”‚   â”‚   â”œâ”€â”€ åŒ–å­¦å­¦ç§‘æœåŠ¡ (åˆ†å­æ¨¡å‹ã€å®éªŒå®¤)
â”‚   â”‚   â”œâ”€â”€ ç”Ÿç‰©å­¦ç§‘æœåŠ¡ (ç»†èƒæ¨¡å‹ã€AIé—®ç­”)
â”‚   â”‚   â”œâ”€â”€ åœ°ç†å­¦ç§‘æœåŠ¡ (3Dåœ°å›¾ã€å¤ªé˜³ç³»)
â”‚   â”‚   â”œâ”€â”€ è¯­æ–‡å­¦ç§‘æœåŠ¡ (æ–‡æœ¬åˆ†æã€AIå†™ä½œ)
â”‚   â”‚   â”œâ”€â”€ è‹±è¯­å­¦ç§‘æœåŠ¡ (è¯­éŸ³è¯†åˆ«ã€ç¿»è¯‘)
â”‚   â”‚   â”œâ”€â”€ å†å²å­¦ç§‘æœåŠ¡ (æ—¶é—´è½´ã€AIåˆ†æ)
â”‚   â”‚   â””â”€â”€ æ”¿æ²»å­¦ç§‘æœåŠ¡ (çŸ¥è¯†å›¾è°±ã€æ¡ˆä¾‹)
â”‚   â”œâ”€â”€ ğŸ¤– AIæœåŠ¡ç¼–æ’
â”‚   â””â”€â”€ ğŸ“Š æ•°æ®æµç®¡ç†
â”‚
â”œâ”€â”€ ğŸ§  é¢†åŸŸå±‚ (Domain Layer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ ğŸ¯ æ•™å­¦èµ„æºç®¡ç†åŸŸ
â”‚   â”‚   â”œâ”€â”€ å¤šåª’ä½“èµ„æºå®ä½“
â”‚   â”‚   â”œâ”€â”€ 3Dæ¨¡å‹èµ„æºå®ä½“
â”‚   â”‚   â””â”€â”€ AIç”Ÿæˆå†…å®¹å®ä½“
â”‚   â”œâ”€â”€ ğŸ‘¥ ç”¨æˆ·å­¦ä¹ åŸŸ
â”‚   â”‚   â”œâ”€â”€ å­¦ä¹ è¿›åº¦å®ä½“
â”‚   â”‚   â”œâ”€â”€ ä¸ªæ€§åŒ–æ¨èå®ä½“
â”‚   â”‚   â””â”€â”€ åä½œå­¦ä¹ å®ä½“
â”‚   â”œâ”€â”€ ğŸ¤– AIæ™ºèƒ½åŸŸ
â”‚   â”‚   â”œâ”€â”€ å›¾åƒè¯†åˆ«æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ æ–‡æœ¬åˆ†ææœåŠ¡
â”‚   â”‚   â”œâ”€â”€ è¯­éŸ³å¤„ç†æœåŠ¡
â”‚   â”‚   â””â”€â”€ å¤šæ¨¡æ€èåˆæœåŠ¡
â”‚   â””â”€â”€ ğŸ® 3Då¯è§†åŒ–åŸŸ
â”‚       â”œâ”€â”€ æ¸²æŸ“å¼•æ“æœåŠ¡
â”‚       â”œâ”€â”€ ç‰©ç†æ¨¡æ‹ŸæœåŠ¡
â”‚       â””â”€â”€ äº¤äº’æ§åˆ¶æœåŠ¡
â”‚
â”œâ”€â”€ ğŸ”§ åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer) â”€â”€ æŠ€æœ¯æ”¯æ’‘
â”‚   â”œâ”€â”€ ğŸ’¾ æ•°æ®æŒä¹…åŒ–
â”‚   â”‚   â”œâ”€â”€ IndexedDB (æœ¬åœ°å­˜å‚¨)
â”‚   â”‚   â”œâ”€â”€ LocalStorage (é…ç½®ç¼“å­˜)
â”‚   â”‚   â””â”€â”€ äº‘ç«¯æ•°æ®åŒæ­¥
â”‚   â”œâ”€â”€ ğŸŒ å¤–éƒ¨æœåŠ¡é›†æˆ
â”‚   â”‚   â”œâ”€â”€ AI APIæœåŠ¡ (SiliconFlow)
â”‚   â”‚   â”œâ”€â”€ CDNèµ„æºæœåŠ¡
â”‚   â”‚   â””â”€â”€ å®æ—¶é€šä¿¡æœåŠ¡ (WebRTC)
â”‚   â”œâ”€â”€ âš¡ æ€§èƒ½ä¼˜åŒ–
â”‚   â”‚   â”œâ”€â”€ Service Workerç¼“å­˜
â”‚   â”‚   â”œâ”€â”€ æ‡’åŠ è½½æœºåˆ¶
â”‚   â”‚   â””â”€â”€ èµ„æºå‹ç¼©ä¼˜åŒ–
â”‚   â””â”€â”€ ğŸ›¡ï¸ å®‰å…¨é˜²æŠ¤
â”‚       â”œâ”€â”€ CSPå†…å®¹å®‰å…¨ç­–ç•¥
â”‚       â”œâ”€â”€ XSSé˜²æŠ¤æœºåˆ¶
â”‚       â””â”€â”€ æ•°æ®åŠ å¯†å­˜å‚¨
â”‚
â””â”€â”€ ğŸ”Œ è·¨å±‚å…³æ³¨ç‚¹ (Cross-Cutting Concerns)
    â”œâ”€â”€ ğŸ“‹ æ—¥å¿—è®°å½•
    â”œâ”€â”€ ğŸš¨ å¼‚å¸¸å¤„ç†
    â”œâ”€â”€ ğŸ“Š æ€§èƒ½ç›‘æ§
    â”œâ”€â”€ ğŸ” å®‰å…¨è®¤è¯
    â””â”€â”€ ğŸŒ å›½é™…åŒ–æ”¯æŒ
```

### ğŸ¨ è®¾è®¡æ¨¡å¼åº”ç”¨

#### ğŸ­ åˆ›å»ºå‹æ¨¡å¼

```javascript
// å·¥å‚æ¨¡å¼ - å­¦ç§‘æ¨¡å—å·¥å‚
class SubjectModuleFactory {
    static createModule(subjectType, config) {
        const modules = {
            'computer': () => new ComputerScienceModule(config),
            'mathematics': () => new MathematicsModule(config),
            'physics': () => new PhysicsModule(config),
            'chemistry': () => new ChemistryModule(config),
            'biology': () => new BiologyModule(config),
            'geography': () => new GeographyModule(config),
            'chinese': () => new ChineseModule(config),
            'english': () => new EnglishModule(config),
            'history': () => new HistoryModule(config),
            'politics': () => new PoliticsModule(config)
        };
        
        const moduleCreator = modules[subjectType];
        if (!moduleCreator) {
            throw new Error(`ä¸æ”¯æŒçš„å­¦ç§‘ç±»å‹: ${subjectType}`);
        }
        
        return moduleCreator();
    }
}

// å»ºé€ è€…æ¨¡å¼ - 3Dåœºæ™¯æ„å»ºå™¨
class Scene3DBuilder {
    constructor() {
        this.scene = new THREE.Scene();
        this.components = [];
    }
    
    addLighting(type, config) {
        const lightFactory = {
            'ambient': () => new THREE.AmbientLight(config.color, config.intensity),
            'directional': () => {
                const light = new THREE.DirectionalLight(config.color, config.intensity);
                light.position.set(...config.position);
                return light;
            },
            'point': () => {
                const light = new THREE.PointLight(config.color, config.intensity, config.distance);
                light.position.set(...config.position);
                return light;
            }
        };
        
        const light = lightFactory[type]();
        this.scene.add(light);
        return this;
    }
    
    addModel(modelConfig) {
        const loader = new THREE.GLTFLoader();
        loader.load(modelConfig.url, (gltf) => {
            const model = gltf.scene;
            model.position.set(...modelConfig.position);
            model.scale.set(...modelConfig.scale);
            this.scene.add(model);
        });
        return this;
    }
    
    addParticleSystem(particleConfig) {
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
            color: particleConfig.color,
            size: particleConfig.size,
            transparent: true,
            opacity: particleConfig.opacity
        });
        
        const particles = new THREE.Points(geometry, material);
        this.scene.add(particles);
        return this;
    }
    
    build() {
        return this.scene;
    }
}

// å•ä¾‹æ¨¡å¼ - å…¨å±€é…ç½®ç®¡ç†å™¨
class ConfigurationManager {
    constructor() {
        if (ConfigurationManager.instance) {
            return ConfigurationManager.instance;
        }
        
        this.config = {
            // ç³»ç»Ÿé…ç½®
            system: {
                version: '1.0.0',
                environment: 'production',
                debugMode: false
            },
            
            // æ¸²æŸ“é…ç½®
            rendering: {
                antialias: true,
                shadows: true,
                maxFPS: 60,
                adaptiveQuality: true
            },
            
            // AIé…ç½®
            ai: {
                apiUrl: 'https://api.siliconflow.cn/v1/chat/completions',
                model: 'Qwen/QwQ-32B',
                maxTokens: 2000,
                temperature: 0.7
            },
            
            // æ€§èƒ½é…ç½®
            performance: {
                lazyLoading: true,
                preloading: true,
                caching: true,
                compression: true
            }
        };
        
        ConfigurationManager.instance = this;
    }
    
    get(path) {
        return path.split('.').reduce((obj, key) => obj?.[key], this.config);
    }
    
    set(path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((obj, key) => obj[key] = obj[key] || {}, this.config);
        target[lastKey] = value;
    }
}
```

#### ğŸ”„ ç»“æ„å‹æ¨¡å¼

```javascript
// é€‚é…å™¨æ¨¡å¼ - AIæœåŠ¡é€‚é…å™¨
class AIServiceAdapter {
    constructor(aiService) {
        this.aiService = aiService;
    }
    
    // ç»Ÿä¸€çš„AIæ¥å£
    async generateResponse(input, context = {}) {
        try {
            // é€‚é…ä¸åŒAIæœåŠ¡çš„è¯·æ±‚æ ¼å¼
            const adaptedRequest = this.adaptRequest(input, context);
            const response = await this.aiService.request(adaptedRequest);
            return this.adaptResponse(response);
        } catch (error) {
            return this.handleError(error);
        }
    }
    
    adaptRequest(input, context) {
        // æ ¹æ®ä¸åŒAIæœåŠ¡é€‚é…è¯·æ±‚æ ¼å¼
        if (this.aiService.type === 'openai') {
            return {
                model: 'gpt-3.5-turbo',
                messages: [
                    { role: 'system', content: context.systemPrompt || 'ä½ æ˜¯ä¸€ä¸ªæ•™å­¦åŠ©æ‰‹' },
                    { role: 'user', content: input }
                ]
            };
        } else if (this.aiService.type === 'siliconflow') {
            return {
                model: 'Qwen/QwQ-32B',
                messages: [
                    { role: 'system', content: context.systemPrompt || 'ä½ æ˜¯ä¸€ä¸ªæ•™å­¦åŠ©æ‰‹' },
                    { role: 'user', content: input }
                ],
                temperature: 0.7,
                max_tokens: 2000
            };
        }
    }
    
    adaptResponse(response) {
        // ç»Ÿä¸€å“åº”æ ¼å¼
        return {
            content: response.choices[0].message.content,
            usage: response.usage,
            model: response.model,
            timestamp: new Date().toISOString()
        };
    }
}

// è£…é¥°å™¨æ¨¡å¼ - æ€§èƒ½ç›‘æ§è£…é¥°å™¨
class PerformanceMonitorDecorator {
    constructor(component) {
        this.component = component;
        this.metrics = new Map();
    }
    
    async execute(method, ...args) {
        const startTime = performance.now();
        const startMemory = performance.memory?.usedJSHeapSize || 0;
        
        try {
            const result = await this.component[method](...args);
            this.recordSuccess(method, startTime, startMemory);
            return result;
        } catch (error) {
            this.recordError(method, startTime, startMemory, error);
            throw error;
        }
    }
    
    recordSuccess(method, startTime, startMemory) {
        const endTime = performance.now();
        const endMemory = performance.memory?.usedJSHeapSize || 0;
        
        const metrics = {
            method,
            duration: endTime - startTime,
            memoryDelta: endMemory - startMemory,
            timestamp: new Date().toISOString(),
            status: 'success'
        };
        
        this.metrics.set(`${method}_${Date.now()}`, metrics);
        console.log(`ğŸ“Š æ€§èƒ½ç›‘æ§ - ${method}: ${metrics.duration.toFixed(2)}ms`);
    }
    
    recordError(method, startTime, startMemory, error) {
        const endTime = performance.now();
        
        const metrics = {
            method,
            duration: endTime - startTime,
            error: error.message,
            timestamp: new Date().toISOString(),
            status: 'error'
        };
        
        this.metrics.set(`${method}_${Date.now()}`, metrics);
        console.error(`âŒ æ€§èƒ½ç›‘æ§ - ${method} æ‰§è¡Œå¤±è´¥: ${error.message}`);
    }
    
    getMetrics() {
        return Array.from(this.metrics.values());
    }
}

// å¤–è§‚æ¨¡å¼ - 3Dæ¸²æŸ“å¤–è§‚
class Rendering3DFacade {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.controls = null;
        this.models = new Map();
        this.animations = new Map();
    }
    
    // ç®€åŒ–çš„åˆå§‹åŒ–æ¥å£
    initialize(container, config = {}) {
        this.setupRenderer(container, config);
        this.setupCamera(config.camera);
        this.setupLighting(config.lighting);
        this.setupControls(config.controls);
        this.startRenderLoop();
    }
    
    // ç®€åŒ–çš„æ¨¡å‹åŠ è½½æ¥å£
    async loadModel(name, url, options = {}) {
        const loader = new THREE.GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
            loader.load(url, resolve, undefined, reject);
        });
        
        const model = gltf.scene;
        if (options.position) model.position.set(...options.position);
        if (options.scale) model.scale.set(...options.scale);
        if (options.rotation) model.rotation.set(...options.rotation);
        
        this.scene.add(model);
        this.models.set(name, model);
        
        return model;
    }
    
    // ç®€åŒ–çš„åŠ¨ç”»æ§åˆ¶æ¥å£
    playAnimation(modelName, animationName) {
        const model = this.models.get(modelName);
        if (!model) return;
        
        const mixer = new THREE.AnimationMixer(model);
        const animation = model.animations.find(anim => anim.name === animationName);
        if (animation) {
            const action = mixer.clipAction(animation);
            action.play();
            this.animations.set(`${modelName}_${animationName}`, { mixer, action });
        }
    }
    
    // ç®€åŒ–çš„åœºæ™¯æ§åˆ¶æ¥å£
    setEnvironment(type) {
        switch (type) {
            case 'space':
                this.scene.background = new THREE.Color(0x000011);
                this.scene.fog = new THREE.Fog(0x000011, 10, 100);
                break;
            case 'laboratory':
                this.scene.background = new THREE.Color(0x1a1a2e);
                this.scene.fog = new THREE.Fog(0x1a1a2e, 5, 50);
                break;
            case 'classroom':
                this.scene.background = new THREE.Color(0x2c3e50);
                break;
        }
    }
}
```

#### ğŸ¯ è¡Œä¸ºå‹æ¨¡å¼

```javascript
// è§‚å¯Ÿè€…æ¨¡å¼ - å­¦ä¹ è¿›åº¦è§‚å¯Ÿå™¨
class LearningProgressObserver {
    constructor() {
        this.observers = new Map();
    }
    
    subscribe(event, callback) {
        if (!this.observers.has(event)) {
            this.observers.set(event, []);
        }
        this.observers.get(event).push(callback);
    }
    
    unsubscribe(event, callback) {
        if (this.observers.has(event)) {
            const callbacks = this.observers.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    
    notify(event, data) {
        if (this.observers.has(event)) {
            this.observers.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`è§‚å¯Ÿè€…å›è°ƒæ‰§è¡Œå¤±è´¥: ${error.message}`);
                }
            });
        }
    }
}

// ç­–ç•¥æ¨¡å¼ - AIæ¨èç­–ç•¥
class RecommendationStrategy {
    // ååŒè¿‡æ»¤ç­–ç•¥
    static collaborativeFiltering = {
        name: 'ååŒè¿‡æ»¤æ¨è',
        weight: 0.3,
        execute: (userProfile, allUsers, content) => {
            // æ‰¾åˆ°ç›¸ä¼¼ç”¨æˆ·
            const similarUsers = allUsers
                .filter(user => user.id !== userProfile.id)
                .map(user => ({
                    user,
                    similarity: this.calculateUserSimilarity(userProfile, user)
                }))
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 10);
            
            // åŸºäºç›¸ä¼¼ç”¨æˆ·çš„åå¥½æ¨èå†…å®¹
            const recommendations = [];
            similarUsers.forEach(({ user, similarity }) => {
                user.preferences.forEach(pref => {
                    if (!userProfile.preferences.includes(pref)) {
                        recommendations.push({
                            content: pref,
                            score: similarity * 0.8,
                            reason: `ä¸æ‚¨ç›¸ä¼¼çš„ç”¨æˆ·ä¹Ÿå–œæ¬¢è¿™ä¸ªå†…å®¹`
                        });
                    }
                });
            });
            
            return recommendations;
        }
    };
    
    // å†…å®¹æ¨èç­–ç•¥
    static contentBased = {
        name: 'åŸºäºå†…å®¹æ¨è',
        weight: 0.25,
        execute: (userProfile, allUsers, content) => {
            const recommendations = [];
            
            content.forEach(item => {
                let score = 0;
                
                // åŸºäºç”¨æˆ·å†å²åå¥½è®¡ç®—ç›¸ä¼¼åº¦
                userProfile.preferences.forEach(pref => {
                    if (item.tags.includes(pref)) {
                        score += 0.8;
                    }
                });
                
                // åŸºäºå­¦ç§‘åŒ¹é…
                if (userProfile.favoriteSubjects.includes(item.subject)) {
                    score += 0.6;
                }
                
                // åŸºäºéš¾åº¦åŒ¹é…
                if (Math.abs(item.difficulty - userProfile.level) <= 1) {
                    score += 0.4;
                }
                
                if (score > 0.5) {
                    recommendations.push({
                        content: item,
                        score,
                        reason: `åŸºäºæ‚¨çš„å­¦ä¹ åå¥½å’Œå†å²è®°å½•`
                    });
                }
            });
            
            return recommendations;
        }
    };
    
    // æ·±åº¦å­¦ä¹ ç­–ç•¥
    static deepLearning = {
        name: 'æ·±åº¦å­¦ä¹ æ¨è',
        weight: 0.25,
        execute: async (userProfile, allUsers, content) => {
            // æ¨¡æ‹Ÿæ·±åº¦å­¦ä¹ æ¨¡å‹æ¨ç†
            const neuralNetwork = new SimpleNeuralNetwork();
            const features = this.extractFeatures(userProfile, content);
            const predictions = await neuralNetwork.predict(features);
            
            return predictions.map((prediction, index) => ({
                content: content[index],
                score: prediction.confidence,
                reason: `AIæ¨¡å‹é¢„æµ‹æ‚¨å¯èƒ½æ„Ÿå…´è¶£`
            }));
        }
    };
    
    // çŸ¥è¯†å›¾è°±ç­–ç•¥
    static knowledgeGraph = {
        name: 'çŸ¥è¯†å›¾è°±æ¨è',
        weight: 0.2,
        execute: (userProfile, allUsers, content) => {
            const knowledgeGraph = this.buildKnowledgeGraph(content);
            const recommendations = [];
            
            // åŸºäºç”¨æˆ·å½“å‰å­¦ä¹ å†…å®¹ï¼Œæ¨èç›¸å…³çŸ¥è¯†ç‚¹
            userProfile.currentLearning.forEach(currentTopic => {
                const relatedTopics = knowledgeGraph.getRelatedTopics(currentTopic);
                relatedTopics.forEach(topic => {
                    const relatedContent = content.filter(item => 
                        item.topics.includes(topic.name)
                    );
                    
                    relatedContent.forEach(item => {
                        recommendations.push({
                            content: item,
                            score: topic.relevance * 0.7,
                            reason: `ä¸æ‚¨æ­£åœ¨å­¦ä¹ çš„"${currentTopic}"ç›¸å…³`
                        });
                    });
                });
            });
            
            return recommendations;
        }
    };
}

// å‘½ä»¤æ¨¡å¼ - ç”¨æˆ·æ“ä½œå‘½ä»¤
class UserActionCommand {
    constructor() {
        this.history = [];
        this.currentIndex = -1;
    }
    
    execute(command) {
        // æ¸…é™¤é‡åšå†å²
        this.history = this.history.slice(0, this.currentIndex + 1);
        
        // æ‰§è¡Œå‘½ä»¤
        command.execute();
        
        // æ·»åŠ åˆ°å†å²
        this.history.push(command);
        this.currentIndex++;
        
        // é™åˆ¶å†å²è®°å½•æ•°é‡
        if (this.history.length > 50) {
            this.history.shift();
            this.currentIndex--;
        }
    }
    
    undo() {
        if (this.currentIndex >= 0) {
            const command = this.history[this.currentIndex];
            command.undo();
            this.currentIndex--;
        }
    }
    
    redo() {
        if (this.currentIndex < this.history.length - 1) {
            this.currentIndex++;
            const command = this.history[this.currentIndex];
            command.execute();
        }
    }
}

// å…·ä½“å‘½ä»¤å®ç°
class Add3DModelCommand {
    constructor(scene, modelData) {
        this.scene = scene;
        this.modelData = modelData;
        this.model = null;
    }
    
    execute() {
        const loader = new THREE.GLTFLoader();
        loader.load(this.modelData.url, (gltf) => {
            this.model = gltf.scene;
            this.model.position.set(...this.modelData.position);
            this.scene.add(this.model);
        });
    }
    
    undo() {
        if (this.model) {
            this.scene.remove(this.model);
        }
    }
}
```

---

## ğŸ—„ï¸ æ•°æ®æ¶æ„è®¾è®¡

### ğŸ“Š æ•°æ®æ¨¡å‹è®¾è®¡

#### ğŸ“ æ ¸å¿ƒå®ä½“æ¨¡å‹

```javascript
// ç”¨æˆ·å®ä½“æ¨¡å‹
class UserEntity {
    constructor(data) {
        this.id = data.id;
        this.username = data.username;
        this.email = data.email;
        this.profile = {
            avatar: data.avatar,
            displayName: data.displayName,
            bio: data.bio,
            level: data.level || 1,
            experience: data.experience || 0,
            achievements: data.achievements || [],
            preferences: {
                subjects: data.favoriteSubjects || [],
                learningStyle: data.learningStyle || 'visual',
                difficulty: data.preferredDifficulty || 'medium',
                language: data.language || 'zh-CN'
            }
        };
        this.learningProgress = {
            totalStudyTime: 0,
            completedLessons: [],
            currentLearning: [],
            weakAreas: [],
            strongAreas: []
        };
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
    }
    
    // æ›´æ–°å­¦ä¹ è¿›åº¦
    updateProgress(subjectId, lessonId, score, timeSpent) {
        this.learningProgress.totalStudyTime += timeSpent;
        
        const progressEntry = {
            subjectId,
            lessonId,
            score,
            timeSpent,
            completedAt: new Date()
        };
        
        this.learningProgress.completedLessons.push(progressEntry);
        this.updatedAt = new Date();
        
        // æ›´æ–°ç»éªŒå€¼
        this.profile.experience += Math.floor(score * 10);
        
        // æ£€æŸ¥ç­‰çº§æå‡
        this.checkLevelUp();
    }
    
    // æ£€æŸ¥ç­‰çº§æå‡
    checkLevelUp() {
        const requiredExp = this.profile.level * 1000;
        if (this.profile.experience >= requiredExp) {
            this.profile.level++;
            this.profile.experience -= requiredExp;
            return true;
        }
        return false;
    }
}

// æ•™å­¦èµ„æºå®ä½“æ¨¡å‹
class TeachingResourceEntity {
    constructor(data) {
        this.id = data.id;
        this.title = data.title;
        this.description = data.description;
        this.subject = data.subject; // å­¦ç§‘åˆ†ç±»
        this.type = data.type; // èµ„æºç±»å‹: '3d-model', '2d-animation', 'video', 'text', 'interactive'
        this.difficulty = data.difficulty; // éš¾åº¦ç­‰çº§: 'beginner', 'intermediate', 'advanced'
        this.tags = data.tags || [];
        this.content = {
            url: data.contentUrl,
            format: data.format,
            size: data.size,
            duration: data.duration,
            metadata: data.metadata || {}
        };
        this.educational = {
            learningObjectives: data.learningObjectives || [],
            prerequisites: data.prerequisites || [],
            targetAudience: data.targetAudience || [],
            assessmentCriteria: data.assessmentCriteria || []
        };
        this.technical = {
            renderingRequirements: data.renderingRequirements || {},
            interactionCapabilities: data.interactionCapabilities || [],
            compatibilityInfo: data.compatibilityInfo || {}
        };
        this.usage = {
            viewCount: 0,
            downloadCount: 0,
            rating: 0,
            reviews: [],
            lastAccessed: null
        };
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
    }
    
    // æ›´æ–°ä½¿ç”¨ç»Ÿè®¡
    updateUsageStats(action, userId) {
        switch (action) {
            case 'view':
                this.usage.viewCount++;
                break;
            case 'download':
                this.usage.downloadCount++;
                break;
        }
        this.usage.lastAccessed = new Date();
        this.updatedAt = new Date();
    }
    
    // æ·»åŠ è¯„ä»·
    addReview(userId, rating, comment) {
        const review = {
            userId,
            rating,
            comment,
            createdAt: new Date()
        };
        
        this.usage.reviews.push(review);
        
        // é‡æ–°è®¡ç®—å¹³å‡è¯„åˆ†
        const totalRating = this.usage.reviews.reduce((sum, review) => sum + review.rating, 0);
        this.usage.rating = totalRating / this.usage.reviews.length;
        
        this.updatedAt = new Date();
    }
}

// AIå¯¹è¯å®ä½“æ¨¡å‹
class AIConversationEntity {
    constructor(data) {
        this.id = data.id;
        this.userId = data.userId;
        this.subject = data.subject;
        this.sessionId = data.sessionId;
        this.messages = data.messages || [];
        this.context = {
            currentTopic: data.currentTopic,
            learningGoal: data.learningGoal,
            userLevel: data.userLevel,
            previousSessions: data.previousSessions || []
        };
        this.metadata = {
            totalMessages: 0,
            averageResponseTime: 0,
            satisfactionScore: 0,
            topics: [],
            keywords: []
        };
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
    }
    
    // æ·»åŠ æ¶ˆæ¯
    addMessage(role, content, metadata = {}) {
        const message = {
            id: this.generateMessageId(),
            role, // 'user' | 'assistant' | 'system'
            content,
            timestamp: new Date(),
            metadata: {
                responseTime: metadata.responseTime,
                confidence: metadata.confidence,
                sources: metadata.sources || [],
                relatedResources: metadata.relatedResources || []
            }
        };
        
        this.messages.push(message);
        this.metadata.totalMessages++;
        this.updatedAt = new Date();
        
        // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
        if (metadata.responseTime) {
            const totalResponseTime = this.metadata.averageResponseTime * (this.metadata.totalMessages - 1) + metadata.responseTime;
            this.metadata.averageResponseTime = totalResponseTime / this.metadata.totalMessages;
        }
        
        return message;
    }
    
    // æå–å¯¹è¯ä¸»é¢˜
    extractTopics() {
        const allContent = this.messages
            .filter(msg => msg.role === 'user')
            .map(msg => msg.content)
            .join(' ');
        
        // ç®€å•çš„å…³é”®è¯æå–ï¼ˆå®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„NLPç®—æ³•ï¼‰
        const keywords = allContent
            .toLowerCase()
            .split(/\s+/)
            .filter(word => word.length > 3)
            .reduce((acc, word) => {
                acc[word] = (acc[word] || 0) + 1;
                return acc;
            }, {});
        
        this.metadata.keywords = Object.entries(keywords)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10)
            .map(([word]) => word);
    }
    
    generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
```

### ğŸ”„ æ•°æ®æµæ¶æ„

#### ğŸ“Š æ•°æ®æµç®¡ç†å™¨

```javascript
// æ•°æ®æµç®¡ç†å™¨
class DataFlowManager {
    constructor() {
        this.streams = new Map();
        this.processors = new Map();
        this.subscribers = new Map();
    }
    
    // åˆ›å»ºæ•°æ®æµ
    createStream(streamId, config = {}) {
        const stream = {
            id: streamId,
            type: config.type || 'realtime',
            buffer: [],
            maxBufferSize: config.maxBufferSize || 1000,
            processors: [],
            subscribers: [],
            isActive: false,
            metadata: {
                createdAt: new Date(),
                totalMessages: 0,
                lastActivity: null
            }
        };
        
        this.streams.set(streamId, stream);
        return stream;
    }
    
    // æ·»åŠ æ•°æ®å¤„ç†å™¨
    addProcessor(streamId, processor) {
        const stream = this.streams.get(streamId);
        if (stream) {
            stream.processors.push(processor);
        }
    }
    
    // å‘é€æ•°æ®åˆ°æµ
    async sendToStream(streamId, data) {
        const stream = this.streams.get(streamId);
        if (!stream) return;
        
        // å¤„ç†æ•°æ®
        let processedData = data;
        for (const processor of stream.processors) {
            processedData = await processor.process(processedData);
        }
        
        // æ·»åŠ åˆ°ç¼“å†²åŒº
        stream.buffer.push({
            data: processedData,
            timestamp: new Date(),
            id: this.generateDataId()
        });
        
        // é™åˆ¶ç¼“å†²åŒºå¤§å°
        if (stream.buffer.length > stream.maxBufferSize) {
            stream.buffer.shift();
        }
        
        // é€šçŸ¥è®¢é˜…è€…
        stream.subscribers.forEach(subscriber => {
            try {
                subscriber.onData(processedData);
            } catch (error) {
                console.error(`æ•°æ®æµè®¢é˜…è€…å¤„ç†å¤±è´¥: ${error.message}`);
            }
        });
        
        // æ›´æ–°å…ƒæ•°æ®
        stream.metadata.totalMessages++;
        stream.metadata.lastActivity = new Date();
    }
    
    // è®¢é˜…æ•°æ®æµ
    subscribe(streamId, subscriber) {
        const stream = this.streams.get(streamId);
        if (stream) {
            stream.subscribers.push(subscriber);
        }
    }
    
    generateDataId() {
        return `data_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// æ•°æ®å¤„ç†å™¨æ¥å£
class DataProcessor {
    constructor(name, processFn) {
        this.name = name;
        this.processFn = processFn;
        this.metrics = {
            processedCount: 0,
            errorCount: 0,
            averageProcessingTime: 0
        };
    }
    
    async process(data) {
        const startTime = performance.now();
        
        try {
            const result = await this.processFn(data);
            this.recordSuccess(startTime);
            return result;
        } catch (error) {
            this.recordError(startTime, error);
            throw error;
        }
    }
    
    recordSuccess(startTime) {
        const processingTime = performance.now() - startTime;
        this.metrics.processedCount++;
        
        const totalTime = this.metrics.averageProcessingTime * (this.metrics.processedCount - 1) + processingTime;
        this.metrics.averageProcessingTime = totalTime / this.metrics.processedCount;
    }
    
    recordError(startTime, error) {
        this.metrics.errorCount++;
        console.error(`æ•°æ®å¤„ç†å™¨ ${this.name} å¤„ç†å¤±è´¥: ${error.message}`);
    }
}
```

---

## ğŸ¤– AIç®—æ³•æ¶æ„

### ğŸ§  AIæœåŠ¡æ¶æ„

#### ğŸ¯ å¤šæ¨¡æ€AIåˆ†æå¼•æ“

```javascript
// å¤šæ¨¡æ€AIåˆ†æå¼•æ“
class MultimodalAIEngine {
    constructor() {
        this.models = new Map();
        this.processors = new Map();
        this.cache = new Map();
        this.config = {
            maxCacheSize: 1000,
            cacheTTL: 300000, // 5åˆ†é’Ÿ
            batchSize: 10,
            timeout: 30000
        };
        
        this.initializeModels();
    }
    
    // åˆå§‹åŒ–AIæ¨¡å‹
    initializeModels() {
        // æ–‡æœ¬åˆ†ææ¨¡å‹
        this.models.set('text-analysis', {
            type: 'nlp',
            capabilities: ['sentiment', 'keywords', 'entities', 'classification'],
            endpoint: 'https://api.siliconflow.cn/v1/chat/completions',
            model: 'Qwen/QwQ-32B'
        });
        
        // å›¾åƒè¯†åˆ«æ¨¡å‹
        this.models.set('image-recognition', {
            type: 'computer-vision',
            capabilities: ['object-detection', 'scene-classification', 'ocr'],
            endpoint: 'https://api.example.com/vision/v1',
            model: 'vision-transformer-large'
        });
        
        // è¯­éŸ³å¤„ç†æ¨¡å‹
        this.models.set('speech-processing', {
            type: 'audio',
            capabilities: ['speech-to-text', 'text-to-speech', 'emotion-detection'],
            endpoint: 'https://api.example.com/speech/v1',
            model: 'whisper-large'
        });
        
        // å¤šæ¨¡æ€èåˆæ¨¡å‹
        this.models.set('multimodal-fusion', {
            type: 'multimodal',
            capabilities: ['cross-modal-understanding', 'content-generation'],
            endpoint: 'https://api.example.com/multimodal/v1',
            model: 'clip-large'
        });
    }
    
    // æ™ºèƒ½å†…å®¹åˆ†æ
    async analyzeContent(content, options = {}) {
        const analysisId = this.generateAnalysisId();
        const startTime = performance.now();
        
        try {
            // æ£€æŸ¥ç¼“å­˜
            const cacheKey = this.generateCacheKey(content, options);
            if (this.cache.has(cacheKey)) {
                const cached = this.cache.get(cacheKey);
                if (Date.now() - cached.timestamp < this.config.cacheTTL) {
                    return cached.result;
                }
            }
            
            // ç¡®å®šå†…å®¹ç±»å‹
            const contentType = this.detectContentType(content);
            
            // é€‰æ‹©åˆé€‚çš„åˆ†æç­–ç•¥
            const analysisStrategy = this.selectAnalysisStrategy(contentType, options);
            
            // æ‰§è¡Œåˆ†æ
            const result = await this.executeAnalysis(content, analysisStrategy, options);
            
            // ç¼“å­˜ç»“æœ
            this.cache.set(cacheKey, {
                result,
                timestamp: Date.now()
            });
            
            // æ¸…ç†è¿‡æœŸç¼“å­˜
            this.cleanupCache();
            
            return {
                ...result,
                analysisId,
                processingTime: performance.now() - startTime,
                contentType,
                strategy: analysisStrategy.name
            };
            
        } catch (error) {
            console.error(`AIå†…å®¹åˆ†æå¤±è´¥: ${error.message}`);
            throw new Error(`åˆ†æå¤±è´¥: ${error.message}`);
        }
    }
    
    // æ£€æµ‹å†…å®¹ç±»å‹
    detectContentType(content) {
        if (typeof content === 'string') {
            return 'text';
        } else if (content instanceof File) {
            if (content.type.startsWith('image/')) {
                return 'image';
            } else if (content.type.startsWith('audio/')) {
                return 'audio';
            } else if (content.type.startsWith('video/')) {
                return 'video';
            }
        } else if (content instanceof ArrayBuffer) {
            return 'binary';
        } else if (Array.isArray(content)) {
            return 'multimodal';
        }
        return 'unknown';
    }
    
    // é€‰æ‹©åˆ†æç­–ç•¥
    selectAnalysisStrategy(contentType, options) {
        const strategies = {
            text: {
                name: 'text-comprehensive',
                models: ['text-analysis'],
                pipeline: [
                    'preprocess',
                    'tokenize',
                    'analyze-sentiment',
                    'extract-keywords',
                    'classify-content',
                    'generate-summary'
                ]
            },
            image: {
                name: 'image-comprehensive',
                models: ['image-recognition'],
                pipeline: [
                    'preprocess',
                    'detect-objects',
                    'classify-scene',
                    'extract-text',
                    'analyze-composition'
                ]
            },
            audio: {
                name: 'audio-comprehensive',
                models: ['speech-processing'],
                pipeline: [
                    'preprocess',
                    'speech-to-text',
                    'analyze-emotion',
                    'extract-features'
                ]
            },
            multimodal: {
                name: 'multimodal-comprehensive',
                models: ['text-analysis', 'image-recognition', 'multimodal-fusion'],
                pipeline: [
                    'separate-modalities',
                    'analyze-individual',
                    'fuse-results',
                    'generate-insights'
                ]
            }
        };
        
        return strategies[contentType] || strategies.text;
    }
    
    // æ‰§è¡Œåˆ†æ
    async executeAnalysis(content, strategy, options) {
        const results = {};
        
        for (const step of strategy.pipeline) {
            const processor = this.processors.get(step);
            if (processor) {
                try {
                    const stepResult = await processor.process(content, results, options);
                    results[step] = stepResult;
                } catch (error) {
                    console.warn(`åˆ†ææ­¥éª¤ ${step} å¤±è´¥: ${error.message}`);
                    results[step] = { error: error.message };
                }
            }
        }
        
        return {
            strategy: strategy.name,
            results,
            confidence: this.calculateConfidence(results),
            recommendations: this.generateRecommendations(results)
        };
    }
    
    // è®¡ç®—ç½®ä¿¡åº¦
    calculateConfidence(results) {
        const confidenceScores = Object.values(results)
            .filter(result => result.confidence !== undefined)
            .map(result => result.confidence);
        
        if (confidenceScores.length === 0) return 0.5;
        
        return confidenceScores.reduce((sum, score) => sum + score, 0) / confidenceScores.length;
    }
    
    // ç”Ÿæˆæ¨è
    generateRecommendations(results) {
        const recommendations = [];
        
        // åŸºäºåˆ†æç»“æœç”Ÿæˆä¸ªæ€§åŒ–æ¨è
        if (results['classify-content']?.category) {
            const category = results['classify-content'].category;
            recommendations.push({
                type: 'related-content',
                title: `æ¢ç´¢æ›´å¤š${category}ç›¸å…³å†…å®¹`,
                reason: 'åŸºäºå†…å®¹åˆ†ç±»åˆ†æ',
                priority: 0.8
            });
        }
        
        if (results['extract-keywords']?.keywords) {
            const keywords = results['extract-keywords'].keywords.slice(0, 3);
            recommendations.push({
                type: 'keyword-expansion',
                title: `æ·±å…¥å­¦ä¹ : ${keywords.join(', ')}`,
                reason: 'åŸºäºå…³é”®è¯åˆ†æ',
                priority: 0.7
            });
        }
        
        return recommendations.sort((a, b) => b.priority - a.priority);
    }
    
    generateAnalysisId() {
        return `analysis_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    generateCacheKey(content, options) {
        const contentHash = this.hashContent(content);
        const optionsHash = this.hashContent(JSON.stringify(options));
        return `${contentHash}_${optionsHash}`;
    }
    
    hashContent(content) {
        // ç®€å•çš„å“ˆå¸Œå‡½æ•°ï¼ˆå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´å¼ºçš„å“ˆå¸Œç®—æ³•ï¼‰
        let hash = 0;
        const str = typeof content === 'string' ? content : JSON.stringify(content);
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
        }
        return hash.toString(36);
    }
    
    cleanupCache() {
        if (this.cache.size > this.config.maxCacheSize) {
            const entries = Array.from(this.cache.entries());
            entries.sort(([,a], [,b]) => a.timestamp - b.timestamp);
            
            const toDelete = entries.slice(0, Math.floor(this.config.maxCacheSize * 0.2));
            toDelete.forEach(([key]) => this.cache.delete(key));
        }
    }
}
```

---

## ğŸ® 3Dæ¸²æŸ“å¼•æ“æ¶æ„

### ğŸš€ Three.jsæ¸²æŸ“ç®¡çº¿è®¾è®¡

#### ğŸ¨ æ¸²æŸ“ç®¡çº¿æ¶æ„

```javascript
// 3Dæ¸²æŸ“å¼•æ“æ ¸å¿ƒæ¶æ„
class Advanced3DRenderingEngine {
    constructor(config = {}) {
        this.config = {
            antialias: config.antialias !== false,
            shadows: config.shadows !== false,
            postProcessing: config.postProcessing !== false,
            adaptiveQuality: config.adaptiveQuality !== false,
            maxFPS: config.maxFPS || 60,
            ...config
        };

        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null; // åå¤„ç†åˆæˆå™¨

        this.renderTargets = new Map();
        this.materials = new Map();
        this.geometries = new Map();
        this.textures = new Map();

        this.performanceMonitor = new RenderingPerformanceMonitor();
        this.qualityController = new AdaptiveQualityController();

        this.init();
    }

    // åˆå§‹åŒ–æ¸²æŸ“å¼•æ“
    init() {
        this.createScene();
        this.createCamera();
        this.createRenderer();
        this.setupLighting();
        this.setupPostProcessing();
        this.startRenderLoop();
    }

    // åˆ›å»ºåœºæ™¯
    createScene() {
        this.scene = new THREE.Scene();

        // è®¾ç½®åœºæ™¯èƒŒæ™¯
        this.scene.background = new THREE.Color(0x000011);

        // æ·»åŠ é›¾æ•ˆ
        this.scene.fog = new THREE.Fog(0x000011, 10, 100);

        // åœºæ™¯å›¾ä¼˜åŒ–
        this.scene.matrixAutoUpdate = false;
    }

    // åˆ›å»ºç›¸æœºç³»ç»Ÿ
    createCamera() {
        this.camera = new THREE.PerspectiveCamera(
            75, // FOV
            window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
            0.1, // è¿‘è£å‰ªé¢
            1000 // è¿œè£å‰ªé¢
        );

        this.camera.position.set(0, 5, 10);
        this.camera.lookAt(0, 0, 0);

        // ç›¸æœºæ§åˆ¶å™¨
        this.cameraController = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.cameraController.enableDamping = true;
        this.cameraController.dampingFactor = 0.05;
    }

    // åˆ›å»ºæ¸²æŸ“å™¨
    createRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            antialias: this.config.antialias,
            alpha: true,
            powerPreference: "high-performance"
        });

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // å¯ç”¨é˜´å½±
        if (this.config.shadows) {
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }

        // è‰²å½©ç®¡ç†
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;

        // æ€§èƒ½ä¼˜åŒ–
        this.renderer.info.autoReset = false;
    }

    // è®¾ç½®å…‰ç…§ç³»ç»Ÿ
    setupLighting() {
        // ç¯å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        this.scene.add(ambientLight);

        // ä¸»å…‰æº
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;

        // é˜´å½±ä¼˜åŒ–
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;

        this.scene.add(directionalLight);

        // è¡¥å…‰
        const fillLight = new THREE.DirectionalLight(0x4080ff, 0.3);
        fillLight.position.set(-10, 5, -5);
        this.scene.add(fillLight);
    }

    // è®¾ç½®åå¤„ç†
    setupPostProcessing() {
        if (!this.config.postProcessing) return;

        this.composer = new THREE.EffectComposer(this.renderer);

        // æ¸²æŸ“é€šé“
        const renderPass = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        // FXAAæŠ—é”¯é½¿
        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.x = 1 / window.innerWidth;
        fxaaPass.material.uniforms['resolution'].value.y = 1 / window.innerHeight;
        this.composer.addPass(fxaaPass);

        // è¾‰å…‰æ•ˆæœ
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // å¼ºåº¦
            0.4, // åŠå¾„
            0.85 // é˜ˆå€¼
        );
        this.composer.addPass(bloomPass);
    }

    // æ¸²æŸ“å¾ªç¯
    startRenderLoop() {
        const animate = () => {
            requestAnimationFrame(animate);

            // æ€§èƒ½ç›‘æ§
            this.performanceMonitor.begin();

            // æ›´æ–°æ§åˆ¶å™¨
            this.cameraController.update();

            // è‡ªé€‚åº”è´¨é‡æ§åˆ¶
            if (this.config.adaptiveQuality) {
                this.qualityController.update(this.performanceMonitor.getFPS());
            }

            // æ¸²æŸ“
            if (this.composer) {
                this.composer.render();
            } else {
                this.renderer.render(this.scene, this.camera);
            }

            // æ€§èƒ½ç›‘æ§ç»“æŸ
            this.performanceMonitor.end();

            // æ¸…ç†æ¸²æŸ“ä¿¡æ¯
            this.renderer.info.reset();
        };

        animate();
    }
}

// æ€§èƒ½ç›‘æ§å™¨
class RenderingPerformanceMonitor {
    constructor() {
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 60;
        this.frameTime = 16.67;
        this.history = [];
        this.maxHistorySize = 60;
    }

    begin() {
        this.startTime = performance.now();
    }

    end() {
        const endTime = performance.now();
        this.frameTime = endTime - this.startTime;
        this.frameCount++;

        // æ¯ç§’è®¡ç®—ä¸€æ¬¡FPS
        if (endTime - this.lastTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastTime = endTime;

            // è®°å½•å†å²
            this.history.push({
                fps: this.fps,
                frameTime: this.frameTime,
                timestamp: endTime
            });

            if (this.history.length > this.maxHistorySize) {
                this.history.shift();
            }
        }
    }

    getFPS() {
        return this.fps;
    }

    getFrameTime() {
        return this.frameTime;
    }

    getAverageFPS() {
        if (this.history.length === 0) return this.fps;

        const sum = this.history.reduce((acc, frame) => acc + frame.fps, 0);
        return sum / this.history.length;
    }
}

// è‡ªé€‚åº”è´¨é‡æ§åˆ¶å™¨
class AdaptiveQualityController {
    constructor() {
        this.targetFPS = 60;
        this.minFPS = 30;
        this.qualityLevel = 1.0; // 0.0 - 1.0
        this.adjustmentThreshold = 5; // FPSå·®å¼‚é˜ˆå€¼
        this.adjustmentRate = 0.1; // è°ƒæ•´é€Ÿç‡
    }

    update(currentFPS) {
        const fpsDiff = this.targetFPS - currentFPS;

        if (Math.abs(fpsDiff) > this.adjustmentThreshold) {
            if (fpsDiff > 0 && this.qualityLevel < 1.0) {
                // FPSä½äºç›®æ ‡ï¼Œé™ä½è´¨é‡
                this.qualityLevel = Math.max(0.1, this.qualityLevel - this.adjustmentRate);
                this.applyQualitySettings();
            } else if (fpsDiff < 0 && this.qualityLevel > 0.1) {
                // FPSé«˜äºç›®æ ‡ï¼Œæé«˜è´¨é‡
                this.qualityLevel = Math.min(1.0, this.qualityLevel + this.adjustmentRate);
                this.applyQualitySettings();
            }
        }
    }

    applyQualitySettings() {
        // æ ¹æ®è´¨é‡ç­‰çº§è°ƒæ•´æ¸²æŸ“è®¾ç½®
        const pixelRatio = Math.min(window.devicePixelRatio, 1 + this.qualityLevel);

        // è°ƒæ•´æ¸²æŸ“åˆ†è¾¨ç‡
        const canvas = document.querySelector('canvas');
        if (canvas) {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            canvas.width = width * pixelRatio * this.qualityLevel;
            canvas.height = height * pixelRatio * this.qualityLevel;
        }

        console.log(`è´¨é‡ç­‰çº§è°ƒæ•´ä¸º: ${(this.qualityLevel * 100).toFixed(1)}%`);
    }
}
```

### ğŸ¯ å­¦ç§‘ä¸“ç”¨æ¸²æŸ“å™¨

#### ğŸ§¬ ç”Ÿç‰©å­¦ç§‘3Dæ¸²æŸ“å™¨

```javascript
// ç”Ÿç‰©å­¦ç§‘ä¸“ç”¨3Dæ¸²æŸ“å™¨
class BiologyRenderer extends Advanced3DRenderingEngine {
    constructor(config) {
        super(config);
        this.moleculeLibrary = new Map();
        this.cellStructures = new Map();
        this.animationMixers = [];

        this.initBiologySpecific();
    }

    initBiologySpecific() {
        // åŠ è½½ç”Ÿç‰©å­¦ä¸“ç”¨æè´¨
        this.loadBiologyMaterials();

        // è®¾ç½®ç”Ÿç‰©å­¦åœºæ™¯ç¯å¢ƒ
        this.setupBiologyEnvironment();

        // åˆå§‹åŒ–åˆ†å­åº“
        this.initMoleculeLibrary();
    }

    loadBiologyMaterials() {
        // DNAæè´¨
        this.materials.set('dna', new THREE.MeshPhongMaterial({
            color: 0x4a90e2,
            transparent: true,
            opacity: 0.8,
            shininess: 100
        }));

        // è›‹ç™½è´¨æè´¨
        this.materials.set('protein', new THREE.MeshLambertMaterial({
            color: 0xe74c3c,
            transparent: true,
            opacity: 0.9
        }));

        // ç»†èƒè†œæè´¨
        this.materials.set('membrane', new THREE.MeshPhysicalMaterial({
            color: 0x95a5a6,
            transparent: true,
            opacity: 0.3,
            transmission: 0.7,
            roughness: 0.1
        }));
    }

    // åˆ›å»ºDNAåŒèºæ—‹ç»“æ„
    createDNAHelix(config = {}) {
        const group = new THREE.Group();
        const radius = config.radius || 2;
        const height = config.height || 10;
        const turns = config.turns || 3;
        const segments = config.segments || 100;

        // åˆ›å»ºèºæ—‹è·¯å¾„
        const curve1 = new THREE.CatmullRomCurve3(this.generateHelixPoints(radius, height, turns, segments, 0));
        const curve2 = new THREE.CatmullRomCurve3(this.generateHelixPoints(radius, height, turns, segments, Math.PI));

        // åˆ›å»ºèºæ—‹å‡ ä½•ä½“
        const tubeGeometry1 = new THREE.TubeGeometry(curve1, segments, 0.1, 8, false);
        const tubeGeometry2 = new THREE.TubeGeometry(curve2, segments, 0.1, 8, false);

        const dnaMaterial = this.materials.get('dna');
        const helix1 = new THREE.Mesh(tubeGeometry1, dnaMaterial);
        const helix2 = new THREE.Mesh(tubeGeometry2, dnaMaterial);

        group.add(helix1, helix2);

        // æ·»åŠ ç¢±åŸºå¯¹è¿æ¥
        this.addBasePairs(group, curve1, curve2, segments);

        return group;
    }

    generateHelixPoints(radius, height, turns, segments, phase) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const angle = turns * 2 * Math.PI * t + phase;
            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);
            const y = height * (t - 0.5);
            points.push(new THREE.Vector3(x, y, z));
        }
        return points;
    }

    addBasePairs(group, curve1, curve2, segments) {
        const basePairGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
        const basePairMaterial = new THREE.MeshPhongMaterial({ color: 0xf39c12 });

        for (let i = 0; i < segments; i += 5) {
            const t = i / segments;
            const point1 = curve1.getPoint(t);
            const point2 = curve2.getPoint(t);

            const basePair = new THREE.Mesh(basePairGeometry, basePairMaterial);
            basePair.position.copy(point1.clone().add(point2).multiplyScalar(0.5));
            basePair.lookAt(point2);
            basePair.rotateX(Math.PI / 2);
            basePair.scale.y = point1.distanceTo(point2);

            group.add(basePair);
        }
    }

    // åˆ›å»ºç»†èƒç»“æ„
    createCellStructure(type, config = {}) {
        const cellGroup = new THREE.Group();

        switch (type) {
            case 'animal':
                return this.createAnimalCell(config);
            case 'plant':
                return this.createPlantCell(config);
            case 'bacteria':
                return this.createBacteriaCell(config);
            default:
                return this.createGenericCell(config);
        }
    }

    createAnimalCell(config) {
        const cellGroup = new THREE.Group();

        // ç»†èƒè†œ
        const membraneGeometry = new THREE.SphereGeometry(5, 32, 32);
        const membrane = new THREE.Mesh(membraneGeometry, this.materials.get('membrane'));
        cellGroup.add(membrane);

        // ç»†èƒæ ¸
        const nucleusGeometry = new THREE.SphereGeometry(2, 16, 16);
        const nucleusMaterial = new THREE.MeshPhongMaterial({ color: 0x8e44ad });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        nucleus.position.set(0, 0, 0);
        cellGroup.add(nucleus);

        // çº¿ç²’ä½“
        for (let i = 0; i < 8; i++) {
            const mitochondria = this.createMitochondria();
            const angle = (i / 8) * Math.PI * 2;
            const radius = 3;
            mitochondria.position.set(
                Math.cos(angle) * radius,
                (Math.random() - 0.5) * 2,
                Math.sin(angle) * radius
            );
            cellGroup.add(mitochondria);
        }

        return cellGroup;
    }

    createMitochondria() {
        const group = new THREE.Group();

        // å¤–è†œ
        const outerGeometry = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
        const outerMaterial = new THREE.MeshPhongMaterial({
            color: 0xe67e22,
            transparent: true,
            opacity: 0.7
        });
        const outer = new THREE.Mesh(outerGeometry, outerMaterial);
        group.add(outer);

        // å†…è†œè¤¶çš±
        for (let i = 0; i < 5; i++) {
            const cristaGeometry = new THREE.PlaneGeometry(0.4, 0.8);
            const cristaMaterial = new THREE.MeshPhongMaterial({
                color: 0xd35400,
                side: THREE.DoubleSide
            });
            const crista = new THREE.Mesh(cristaGeometry, cristaMaterial);
            crista.position.x = (i - 2) * 0.2;
            crista.rotation.y = Math.PI / 2;
            group.add(crista);
        }

        return group;
    }
}
```

---

## ğŸ“± ç”¨æˆ·ç•Œé¢è®¾è®¡è§„èŒƒ

### ğŸ¨ è®¾è®¡ç³»ç»Ÿæ¶æ„

#### ğŸŒˆ è‰²å½©ç³»ç»Ÿè®¾è®¡

```javascript
// åå¤§å­¦ç§‘è‰²å½©ç³»ç»Ÿ
const SubjectColorSystem = {
    // å­¦ç§‘ä¸»è‰²è°ƒ
    subjects: {
        computer: {
            primary: '#00d4ff',      // ç§‘æŠ€è“
            secondary: '#0099cc',    // æ·±è“
            accent: '#66e6ff',       // äº®è“
            background: '#001122',   // æ·±è“èƒŒæ™¯
            text: '#ffffff'          // ç™½è‰²æ–‡å­—
        },
        mathematics: {
            primary: '#ff6b35',      // æ•°å­¦æ©™
            secondary: '#cc5429',    // æ·±æ©™
            accent: '#ff8c66',       // äº®æ©™
            background: '#1a0f0a',   // æ·±æ©™èƒŒæ™¯
            text: '#ffffff'
        },
        physics: {
            primary: '#8a2be2',      // ç‰©ç†ç´«
            secondary: '#6a1b9a',    // æ·±ç´«
            accent: '#ba68c8',       // äº®ç´«
            background: '#1a0d1f',   // æ·±ç´«èƒŒæ™¯
            text: '#ffffff'
        },
        chemistry: {
            primary: '#4caf50',      // åŒ–å­¦ç»¿
            secondary: '#388e3c',    // æ·±ç»¿
            accent: '#81c784',       // äº®ç»¿
            background: '#0d1f0f',   // æ·±ç»¿èƒŒæ™¯
            text: '#ffffff'
        },
        biology: {
            primary: '#ff9800',      // ç”Ÿç‰©æ©™é»„
            secondary: '#f57c00',    // æ·±æ©™é»„
            accent: '#ffb74d',       // äº®æ©™é»„
            background: '#1f1509',   // æ·±æ©™é»„èƒŒæ™¯
            text: '#ffffff'
        },
        geography: {
            primary: '#2196f3',      // åœ°ç†è“
            secondary: '#1976d2',    // æ·±è“
            accent: '#64b5f6',       // äº®è“
            background: '#0a1929',   // æ·±è“èƒŒæ™¯
            text: '#ffffff'
        },
        chinese: {
            primary: '#e91e63',      // è¯­æ–‡çº¢
            secondary: '#c2185b',    // æ·±çº¢
            accent: '#f06292',       // äº®çº¢
            background: '#1f0a14',   // æ·±çº¢èƒŒæ™¯
            text: '#ffffff'
        },
        english: {
            primary: '#9c27b0',      // è‹±è¯­ç´«çº¢
            secondary: '#7b1fa2',    // æ·±ç´«çº¢
            accent: '#ce93d8',       // äº®ç´«çº¢
            background: '#1a0d1f',   // æ·±ç´«çº¢èƒŒæ™¯
            text: '#ffffff'
        },
        history: {
            primary: '#795548',      // å†å²æ£•
            secondary: '#5d4037',    // æ·±æ£•
            accent: '#a1887f',       // äº®æ£•
            background: '#1a1611',   // æ·±æ£•èƒŒæ™¯
            text: '#ffffff'
        },
        politics: {
            primary: '#f44336',      // æ”¿æ²»çº¢
            secondary: '#d32f2f',    // æ·±çº¢
            accent: '#ef5350',       // äº®çº¢
            background: '#1f0a0a',   // æ·±çº¢èƒŒæ™¯
            text: '#ffffff'
        }
    },

    // é€šç”¨è‰²å½©
    common: {
        success: '#4caf50',
        warning: '#ff9800',
        error: '#f44336',
        info: '#2196f3',
        background: {
            primary: '#0a0a24',     // ä¸»èƒŒæ™¯
            secondary: '#1a1a3e',   // æ¬¡èƒŒæ™¯
            surface: '#2a2a5e',     // è¡¨é¢
            overlay: 'rgba(0,0,0,0.7)'
        },
        text: {
            primary: '#ffffff',
            secondary: '#b0b0b0',
            disabled: '#666666'
        }
    },

    // è·å–å­¦ç§‘è‰²å½©
    getSubjectColors(subject) {
        return this.subjects[subject] || this.subjects.computer;
    },

    // ç”Ÿæˆæ¸å˜è‰²
    generateGradient(subject, direction = 'to right') {
        const colors = this.getSubjectColors(subject);
        return `linear-gradient(${direction}, ${colors.primary}, ${colors.secondary})`;
    },

    // ç”Ÿæˆå‘å…‰æ•ˆæœ
    generateGlow(subject, intensity = 0.5) {
        const colors = this.getSubjectColors(subject);
        return `0 0 ${20 * intensity}px ${colors.primary}${Math.floor(intensity * 255).toString(16)}`;
    }
};
```

#### ğŸ­ ç»„ä»¶è®¾è®¡ç³»ç»Ÿ

```javascript
// UIç»„ä»¶è®¾è®¡ç³»ç»Ÿ
class UIComponentSystem {
    constructor() {
        this.components = new Map();
        this.themes = new Map();
        this.animations = new Map();

        this.initializeComponents();
        this.initializeThemes();
        this.initializeAnimations();
    }

    // åˆå§‹åŒ–ç»„ä»¶åº“
    initializeComponents() {
        // æŒ‰é’®ç»„ä»¶
        this.components.set('button', {
            variants: {
                primary: {
                    background: 'var(--subject-primary)',
                    color: 'var(--subject-text)',
                    border: 'none',
                    borderRadius: '8px',
                    padding: '12px 24px',
                    fontSize: '16px',
                    fontWeight: '600',
                    cursor: 'pointer',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.2)',
                    ':hover': {
                        transform: 'translateY(-2px)',
                        boxShadow: '0 6px 20px rgba(0,0,0,0.3)'
                    }
                },
                secondary: {
                    background: 'transparent',
                    color: 'var(--subject-primary)',
                    border: '2px solid var(--subject-primary)',
                    borderRadius: '8px',
                    padding: '10px 22px',
                    fontSize: '16px',
                    fontWeight: '600',
                    cursor: 'pointer',
                    transition: 'all 0.3s ease',
                    ':hover': {
                        background: 'var(--subject-primary)',
                        color: 'var(--subject-text)'
                    }
                },
                ghost: {
                    background: 'rgba(255,255,255,0.1)',
                    color: 'var(--subject-text)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '8px',
                    padding: '12px 24px',
                    fontSize: '16px',
                    fontWeight: '500',
                    cursor: 'pointer',
                    backdropFilter: 'blur(10px)',
                    transition: 'all 0.3s ease',
                    ':hover': {
                        background: 'rgba(255,255,255,0.2)',
                        borderColor: 'rgba(255,255,255,0.4)'
                    }
                }
            }
        });

        // å¡ç‰‡ç»„ä»¶
        this.components.set('card', {
            variants: {
                default: {
                    background: 'rgba(255,255,255,0.05)',
                    border: '1px solid rgba(255,255,255,0.1)',
                    borderRadius: '16px',
                    padding: '24px',
                    backdropFilter: 'blur(20px)',
                    boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
                    transition: 'all 0.3s ease',
                    ':hover': {
                        transform: 'translateY(-4px)',
                        boxShadow: '0 12px 40px rgba(0,0,0,0.4)',
                        borderColor: 'rgba(255,255,255,0.2)'
                    }
                },
                glass: {
                    background: 'rgba(255,255,255,0.08)',
                    border: '1px solid rgba(255,255,255,0.15)',
                    borderRadius: '20px',
                    padding: '32px',
                    backdropFilter: 'blur(25px)',
                    boxShadow: '0 12px 48px rgba(0,0,0,0.2)',
                    position: 'relative',
                    overflow: 'hidden',
                    '::before': {
                        content: '""',
                        position: 'absolute',
                        top: '0',
                        left: '0',
                        right: '0',
                        height: '1px',
                        background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent)'
                    }
                }
            }
        });

        // è¾“å…¥æ¡†ç»„ä»¶
        this.components.set('input', {
            variants: {
                default: {
                    background: 'rgba(255,255,255,0.05)',
                    border: '2px solid rgba(255,255,255,0.1)',
                    borderRadius: '12px',
                    padding: '16px 20px',
                    fontSize: '16px',
                    color: 'var(--subject-text)',
                    outline: 'none',
                    transition: 'all 0.3s ease',
                    ':focus': {
                        borderColor: 'var(--subject-primary)',
                        boxShadow: '0 0 0 4px rgba(var(--subject-primary-rgb), 0.2)',
                        background: 'rgba(255,255,255,0.08)'
                    },
                    '::placeholder': {
                        color: 'rgba(255,255,255,0.5)'
                    }
                }
            }
        });
    }

    // åˆ›å»ºç»„ä»¶
    createComponent(type, variant = 'default', props = {}) {
        const componentDef = this.components.get(type);
        if (!componentDef) {
            throw new Error(`æœªçŸ¥ç»„ä»¶ç±»å‹: ${type}`);
        }

        const variantStyles = componentDef.variants[variant];
        if (!variantStyles) {
            throw new Error(`æœªçŸ¥ç»„ä»¶å˜ä½“: ${type}.${variant}`);
        }

        const element = document.createElement(props.tag || 'div');

        // åº”ç”¨æ ·å¼
        Object.entries(variantStyles).forEach(([property, value]) => {
            if (property.startsWith(':') || property.startsWith('::')) {
                // å¤„ç†ä¼ªç±»å’Œä¼ªå…ƒç´ 
                this.addPseudoStyles(element, property, value);
            } else {
                element.style[property] = value;
            }
        });

        // åº”ç”¨è‡ªå®šä¹‰å±æ€§
        Object.entries(props).forEach(([key, value]) => {
            if (key !== 'tag' && key !== 'children') {
                if (key.startsWith('on')) {
                    // äº‹ä»¶å¤„ç†å™¨
                    const eventName = key.slice(2).toLowerCase();
                    element.addEventListener(eventName, value);
                } else if (key === 'className') {
                    element.className = value;
                } else if (key === 'style') {
                    Object.assign(element.style, value);
                } else {
                    element.setAttribute(key, value);
                }
            }
        });

        // æ·»åŠ å­å…ƒç´ 
        if (props.children) {
            if (typeof props.children === 'string') {
                element.textContent = props.children;
            } else if (Array.isArray(props.children)) {
                props.children.forEach(child => {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    } else {
                        element.appendChild(child);
                    }
                });
            } else {
                element.appendChild(props.children);
            }
        }

        return element;
    }

    // æ·»åŠ ä¼ªç±»æ ·å¼
    addPseudoStyles(element, pseudo, styles) {
        const className = `component-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        element.classList.add(className);

        const styleSheet = document.styleSheets[0] || this.createStyleSheet();
        const rule = `.${className}${pseudo} { ${this.stylesToCSS(styles)} }`;

        try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
        } catch (error) {
            console.warn('æ— æ³•æ’å…¥CSSè§„åˆ™:', rule, error);
        }
    }

    // æ ·å¼å¯¹è±¡è½¬CSSå­—ç¬¦ä¸²
    stylesToCSS(styles) {
        return Object.entries(styles)
            .map(([property, value]) => `${this.camelToKebab(property)}: ${value}`)
            .join('; ');
    }

    // é©¼å³°è½¬çŸ­æ¨ªçº¿
    camelToKebab(str) {
        return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
    }

    // åˆ›å»ºæ ·å¼è¡¨
    createStyleSheet() {
        const style = document.createElement('style');
        document.head.appendChild(style);
        return style.sheet;
    }
}
```

---

*æœ¬æ–‡æ¡£ç”± @æ˜Ÿæ¢¦æ¸¸Xmy äº2025å¹´7æœˆç‹¬ç«‹ç¼–å†™ï¼Œè¯¦ç»†é˜è¿°äº†åå¤§å­¦ç§‘å¤šæ¨¡æ€æ•™å­¦èµ„æºåˆ¶ä½œç®¡ç†ç³»ç»Ÿçš„è½¯ä»¶æ¶æ„è®¾è®¡å’ŒæŠ€æœ¯å®ç°æ–¹æ¡ˆã€‚*

**ğŸŒŸ ç”¨ä»£ç æ„å»ºæ•™è‚²çš„æœªæ¥ï¼Œè®©æŠ€æœ¯æˆä¸ºçŸ¥è¯†ä¼ æ’­çš„æ¡¥æ¢ï¼**
