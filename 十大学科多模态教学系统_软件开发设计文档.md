# 🏗️ 十大学科多模态教学资源制作管理系统 - 软件开发设计文档

<div align="center">

![架构版本](https://img.shields.io/badge/架构版本-v1.0.0-00f7ff?style=for-the-badge&logo=architecture)
![设计模式](https://img.shields.io/badge/设计模式-微服务%20%7C%20组件化-ff00aa?style=for-the-badge&logo=design)
![技术栈](https://img.shields.io/badge/技术栈-现代化全栈-00ff88?style=for-the-badge&logo=tech)
![开发规范](https://img.shields.io/badge/开发规范-企业级-orange?style=for-the-badge&logo=standard)

**🌟 基于现代化技术栈的革命性教育平台架构设计**

*项目开发：2025年7月由 @星梦游Xmy 独立开发*

---

### 📊 系统技术概览
🎯 **10大学科** | 🏗️ **微服务架构** | 🤖 **20+AI模型** | 🎮 **3D可视化** | 📱 **全平台支持**

</div>

---

## 🎯 系统架构设计

### 🏛️ 整体架构设计理念

本系统采用**现代化微服务架构**，结合**组件化设计模式**和**领域驱动设计(DDD)**，构建高内聚、低耦合的教育技术平台。系统遵循**SOLID原则**和**Clean Architecture**理念，确保代码的可维护性、可扩展性和可测试性。

### 📊 系统架构全景图

```
🌟 十大学科多模态教学系统架构
│
├── 🎨 表现层 (Presentation Layer) ─────── 用户界面与交互
│   ├── 🌐 Web前端应用 (SPA)
│   │   ├── React组件库 (地理3D地图)
│   │   ├── 原生JavaScript模块 (其他学科)
│   │   └── PWA渐进式应用
│   ├── 📱 移动端适配
│   └── 🎮 3D交互界面
│
├── 🔄 应用层 (Application Layer) ────── 业务流程编排
│   ├── 🎓 学科业务服务
│   │   ├── 计算机学科服务 (AI助手、3D硬件)
│   │   ├── 数学学科服务 (公式编辑、3D几何)
│   │   ├── 物理学科服务 (物理模拟、实验)
│   │   ├── 化学学科服务 (分子模型、实验室)
│   │   ├── 生物学科服务 (细胞模型、AI问答)
│   │   ├── 地理学科服务 (3D地图、太阳系)
│   │   ├── 语文学科服务 (文本分析、AI写作)
│   │   ├── 英语学科服务 (语音识别、翻译)
│   │   ├── 历史学科服务 (时间轴、AI分析)
│   │   └── 政治学科服务 (知识图谱、案例)
│   ├── 🤖 AI服务编排
│   └── 📊 数据流管理
│
├── 🧠 领域层 (Domain Layer) ──────────── 核心业务逻辑
│   ├── 🎯 教学资源管理域
│   │   ├── 多媒体资源实体
│   │   ├── 3D模型资源实体
│   │   └── AI生成内容实体
│   ├── 👥 用户学习域
│   │   ├── 学习进度实体
│   │   ├── 个性化推荐实体
│   │   └── 协作学习实体
│   ├── 🤖 AI智能域
│   │   ├── 图像识别服务
│   │   ├── 文本分析服务
│   │   ├── 语音处理服务
│   │   └── 多模态融合服务
│   └── 🎮 3D可视化域
│       ├── 渲染引擎服务
│       ├── 物理模拟服务
│       └── 交互控制服务
│
├── 🔧 基础设施层 (Infrastructure Layer) ── 技术支撑
│   ├── 💾 数据持久化
│   │   ├── IndexedDB (本地存储)
│   │   ├── LocalStorage (配置缓存)
│   │   └── 云端数据同步
│   ├── 🌐 外部服务集成
│   │   ├── AI API服务 (SiliconFlow)
│   │   ├── CDN资源服务
│   │   └── 实时通信服务 (WebRTC)
│   ├── ⚡ 性能优化
│   │   ├── Service Worker缓存
│   │   ├── 懒加载机制
│   │   └── 资源压缩优化
│   └── 🛡️ 安全防护
│       ├── CSP内容安全策略
│       ├── XSS防护机制
│       └── 数据加密存储
│
└── 🔌 跨层关注点 (Cross-Cutting Concerns)
    ├── 📋 日志记录
    ├── 🚨 异常处理
    ├── 📊 性能监控
    ├── 🔐 安全认证
    └── 🌐 国际化支持
```

### 🎨 设计模式应用

#### 🏭 创建型模式

```javascript
// 工厂模式 - 学科模块工厂
class SubjectModuleFactory {
    static createModule(subjectType, config) {
        const modules = {
            'computer': () => new ComputerScienceModule(config),
            'mathematics': () => new MathematicsModule(config),
            'physics': () => new PhysicsModule(config),
            'chemistry': () => new ChemistryModule(config),
            'biology': () => new BiologyModule(config),
            'geography': () => new GeographyModule(config),
            'chinese': () => new ChineseModule(config),
            'english': () => new EnglishModule(config),
            'history': () => new HistoryModule(config),
            'politics': () => new PoliticsModule(config)
        };
        
        const moduleCreator = modules[subjectType];
        if (!moduleCreator) {
            throw new Error(`不支持的学科类型: ${subjectType}`);
        }
        
        return moduleCreator();
    }
}

// 建造者模式 - 3D场景构建器
class Scene3DBuilder {
    constructor() {
        this.scene = new THREE.Scene();
        this.components = [];
    }
    
    addLighting(type, config) {
        const lightFactory = {
            'ambient': () => new THREE.AmbientLight(config.color, config.intensity),
            'directional': () => {
                const light = new THREE.DirectionalLight(config.color, config.intensity);
                light.position.set(...config.position);
                return light;
            },
            'point': () => {
                const light = new THREE.PointLight(config.color, config.intensity, config.distance);
                light.position.set(...config.position);
                return light;
            }
        };
        
        const light = lightFactory[type]();
        this.scene.add(light);
        return this;
    }
    
    addModel(modelConfig) {
        const loader = new THREE.GLTFLoader();
        loader.load(modelConfig.url, (gltf) => {
            const model = gltf.scene;
            model.position.set(...modelConfig.position);
            model.scale.set(...modelConfig.scale);
            this.scene.add(model);
        });
        return this;
    }
    
    addParticleSystem(particleConfig) {
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
            color: particleConfig.color,
            size: particleConfig.size,
            transparent: true,
            opacity: particleConfig.opacity
        });
        
        const particles = new THREE.Points(geometry, material);
        this.scene.add(particles);
        return this;
    }
    
    build() {
        return this.scene;
    }
}

// 单例模式 - 全局配置管理器
class ConfigurationManager {
    constructor() {
        if (ConfigurationManager.instance) {
            return ConfigurationManager.instance;
        }
        
        this.config = {
            // 系统配置
            system: {
                version: '1.0.0',
                environment: 'production',
                debugMode: false
            },
            
            // 渲染配置
            rendering: {
                antialias: true,
                shadows: true,
                maxFPS: 60,
                adaptiveQuality: true
            },
            
            // AI配置
            ai: {
                apiUrl: 'https://api.siliconflow.cn/v1/chat/completions',
                model: 'Qwen/QwQ-32B',
                maxTokens: 2000,
                temperature: 0.7
            },
            
            // 性能配置
            performance: {
                lazyLoading: true,
                preloading: true,
                caching: true,
                compression: true
            }
        };
        
        ConfigurationManager.instance = this;
    }
    
    get(path) {
        return path.split('.').reduce((obj, key) => obj?.[key], this.config);
    }
    
    set(path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((obj, key) => obj[key] = obj[key] || {}, this.config);
        target[lastKey] = value;
    }
}
```

#### 🔄 结构型模式

```javascript
// 适配器模式 - AI服务适配器
class AIServiceAdapter {
    constructor(aiService) {
        this.aiService = aiService;
    }
    
    // 统一的AI接口
    async generateResponse(input, context = {}) {
        try {
            // 适配不同AI服务的请求格式
            const adaptedRequest = this.adaptRequest(input, context);
            const response = await this.aiService.request(adaptedRequest);
            return this.adaptResponse(response);
        } catch (error) {
            return this.handleError(error);
        }
    }
    
    adaptRequest(input, context) {
        // 根据不同AI服务适配请求格式
        if (this.aiService.type === 'openai') {
            return {
                model: 'gpt-3.5-turbo',
                messages: [
                    { role: 'system', content: context.systemPrompt || '你是一个教学助手' },
                    { role: 'user', content: input }
                ]
            };
        } else if (this.aiService.type === 'siliconflow') {
            return {
                model: 'Qwen/QwQ-32B',
                messages: [
                    { role: 'system', content: context.systemPrompt || '你是一个教学助手' },
                    { role: 'user', content: input }
                ],
                temperature: 0.7,
                max_tokens: 2000
            };
        }
    }
    
    adaptResponse(response) {
        // 统一响应格式
        return {
            content: response.choices[0].message.content,
            usage: response.usage,
            model: response.model,
            timestamp: new Date().toISOString()
        };
    }
}

// 装饰器模式 - 性能监控装饰器
class PerformanceMonitorDecorator {
    constructor(component) {
        this.component = component;
        this.metrics = new Map();
    }
    
    async execute(method, ...args) {
        const startTime = performance.now();
        const startMemory = performance.memory?.usedJSHeapSize || 0;
        
        try {
            const result = await this.component[method](...args);
            this.recordSuccess(method, startTime, startMemory);
            return result;
        } catch (error) {
            this.recordError(method, startTime, startMemory, error);
            throw error;
        }
    }
    
    recordSuccess(method, startTime, startMemory) {
        const endTime = performance.now();
        const endMemory = performance.memory?.usedJSHeapSize || 0;
        
        const metrics = {
            method,
            duration: endTime - startTime,
            memoryDelta: endMemory - startMemory,
            timestamp: new Date().toISOString(),
            status: 'success'
        };
        
        this.metrics.set(`${method}_${Date.now()}`, metrics);
        console.log(`📊 性能监控 - ${method}: ${metrics.duration.toFixed(2)}ms`);
    }
    
    recordError(method, startTime, startMemory, error) {
        const endTime = performance.now();
        
        const metrics = {
            method,
            duration: endTime - startTime,
            error: error.message,
            timestamp: new Date().toISOString(),
            status: 'error'
        };
        
        this.metrics.set(`${method}_${Date.now()}`, metrics);
        console.error(`❌ 性能监控 - ${method} 执行失败: ${error.message}`);
    }
    
    getMetrics() {
        return Array.from(this.metrics.values());
    }
}

// 外观模式 - 3D渲染外观
class Rendering3DFacade {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.controls = null;
        this.models = new Map();
        this.animations = new Map();
    }
    
    // 简化的初始化接口
    initialize(container, config = {}) {
        this.setupRenderer(container, config);
        this.setupCamera(config.camera);
        this.setupLighting(config.lighting);
        this.setupControls(config.controls);
        this.startRenderLoop();
    }
    
    // 简化的模型加载接口
    async loadModel(name, url, options = {}) {
        const loader = new THREE.GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
            loader.load(url, resolve, undefined, reject);
        });
        
        const model = gltf.scene;
        if (options.position) model.position.set(...options.position);
        if (options.scale) model.scale.set(...options.scale);
        if (options.rotation) model.rotation.set(...options.rotation);
        
        this.scene.add(model);
        this.models.set(name, model);
        
        return model;
    }
    
    // 简化的动画控制接口
    playAnimation(modelName, animationName) {
        const model = this.models.get(modelName);
        if (!model) return;
        
        const mixer = new THREE.AnimationMixer(model);
        const animation = model.animations.find(anim => anim.name === animationName);
        if (animation) {
            const action = mixer.clipAction(animation);
            action.play();
            this.animations.set(`${modelName}_${animationName}`, { mixer, action });
        }
    }
    
    // 简化的场景控制接口
    setEnvironment(type) {
        switch (type) {
            case 'space':
                this.scene.background = new THREE.Color(0x000011);
                this.scene.fog = new THREE.Fog(0x000011, 10, 100);
                break;
            case 'laboratory':
                this.scene.background = new THREE.Color(0x1a1a2e);
                this.scene.fog = new THREE.Fog(0x1a1a2e, 5, 50);
                break;
            case 'classroom':
                this.scene.background = new THREE.Color(0x2c3e50);
                break;
        }
    }
}
```

#### 🎯 行为型模式

```javascript
// 观察者模式 - 学习进度观察器
class LearningProgressObserver {
    constructor() {
        this.observers = new Map();
    }
    
    subscribe(event, callback) {
        if (!this.observers.has(event)) {
            this.observers.set(event, []);
        }
        this.observers.get(event).push(callback);
    }
    
    unsubscribe(event, callback) {
        if (this.observers.has(event)) {
            const callbacks = this.observers.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    
    notify(event, data) {
        if (this.observers.has(event)) {
            this.observers.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`观察者回调执行失败: ${error.message}`);
                }
            });
        }
    }
}

// 策略模式 - AI推荐策略
class RecommendationStrategy {
    // 协同过滤策略
    static collaborativeFiltering = {
        name: '协同过滤推荐',
        weight: 0.3,
        execute: (userProfile, allUsers, content) => {
            // 找到相似用户
            const similarUsers = allUsers
                .filter(user => user.id !== userProfile.id)
                .map(user => ({
                    user,
                    similarity: this.calculateUserSimilarity(userProfile, user)
                }))
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 10);
            
            // 基于相似用户的偏好推荐内容
            const recommendations = [];
            similarUsers.forEach(({ user, similarity }) => {
                user.preferences.forEach(pref => {
                    if (!userProfile.preferences.includes(pref)) {
                        recommendations.push({
                            content: pref,
                            score: similarity * 0.8,
                            reason: `与您相似的用户也喜欢这个内容`
                        });
                    }
                });
            });
            
            return recommendations;
        }
    };
    
    // 内容推荐策略
    static contentBased = {
        name: '基于内容推荐',
        weight: 0.25,
        execute: (userProfile, allUsers, content) => {
            const recommendations = [];
            
            content.forEach(item => {
                let score = 0;
                
                // 基于用户历史偏好计算相似度
                userProfile.preferences.forEach(pref => {
                    if (item.tags.includes(pref)) {
                        score += 0.8;
                    }
                });
                
                // 基于学科匹配
                if (userProfile.favoriteSubjects.includes(item.subject)) {
                    score += 0.6;
                }
                
                // 基于难度匹配
                if (Math.abs(item.difficulty - userProfile.level) <= 1) {
                    score += 0.4;
                }
                
                if (score > 0.5) {
                    recommendations.push({
                        content: item,
                        score,
                        reason: `基于您的学习偏好和历史记录`
                    });
                }
            });
            
            return recommendations;
        }
    };
    
    // 深度学习策略
    static deepLearning = {
        name: '深度学习推荐',
        weight: 0.25,
        execute: async (userProfile, allUsers, content) => {
            // 模拟深度学习模型推理
            const neuralNetwork = new SimpleNeuralNetwork();
            const features = this.extractFeatures(userProfile, content);
            const predictions = await neuralNetwork.predict(features);
            
            return predictions.map((prediction, index) => ({
                content: content[index],
                score: prediction.confidence,
                reason: `AI模型预测您可能感兴趣`
            }));
        }
    };
    
    // 知识图谱策略
    static knowledgeGraph = {
        name: '知识图谱推荐',
        weight: 0.2,
        execute: (userProfile, allUsers, content) => {
            const knowledgeGraph = this.buildKnowledgeGraph(content);
            const recommendations = [];
            
            // 基于用户当前学习内容，推荐相关知识点
            userProfile.currentLearning.forEach(currentTopic => {
                const relatedTopics = knowledgeGraph.getRelatedTopics(currentTopic);
                relatedTopics.forEach(topic => {
                    const relatedContent = content.filter(item => 
                        item.topics.includes(topic.name)
                    );
                    
                    relatedContent.forEach(item => {
                        recommendations.push({
                            content: item,
                            score: topic.relevance * 0.7,
                            reason: `与您正在学习的"${currentTopic}"相关`
                        });
                    });
                });
            });
            
            return recommendations;
        }
    };
}

// 命令模式 - 用户操作命令
class UserActionCommand {
    constructor() {
        this.history = [];
        this.currentIndex = -1;
    }
    
    execute(command) {
        // 清除重做历史
        this.history = this.history.slice(0, this.currentIndex + 1);
        
        // 执行命令
        command.execute();
        
        // 添加到历史
        this.history.push(command);
        this.currentIndex++;
        
        // 限制历史记录数量
        if (this.history.length > 50) {
            this.history.shift();
            this.currentIndex--;
        }
    }
    
    undo() {
        if (this.currentIndex >= 0) {
            const command = this.history[this.currentIndex];
            command.undo();
            this.currentIndex--;
        }
    }
    
    redo() {
        if (this.currentIndex < this.history.length - 1) {
            this.currentIndex++;
            const command = this.history[this.currentIndex];
            command.execute();
        }
    }
}

// 具体命令实现
class Add3DModelCommand {
    constructor(scene, modelData) {
        this.scene = scene;
        this.modelData = modelData;
        this.model = null;
    }
    
    execute() {
        const loader = new THREE.GLTFLoader();
        loader.load(this.modelData.url, (gltf) => {
            this.model = gltf.scene;
            this.model.position.set(...this.modelData.position);
            this.scene.add(this.model);
        });
    }
    
    undo() {
        if (this.model) {
            this.scene.remove(this.model);
        }
    }
}
```

---

## 🗄️ 数据架构设计

### 📊 数据模型设计

#### 🎓 核心实体模型

```javascript
// 用户实体模型
class UserEntity {
    constructor(data) {
        this.id = data.id;
        this.username = data.username;
        this.email = data.email;
        this.profile = {
            avatar: data.avatar,
            displayName: data.displayName,
            bio: data.bio,
            level: data.level || 1,
            experience: data.experience || 0,
            achievements: data.achievements || [],
            preferences: {
                subjects: data.favoriteSubjects || [],
                learningStyle: data.learningStyle || 'visual',
                difficulty: data.preferredDifficulty || 'medium',
                language: data.language || 'zh-CN'
            }
        };
        this.learningProgress = {
            totalStudyTime: 0,
            completedLessons: [],
            currentLearning: [],
            weakAreas: [],
            strongAreas: []
        };
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
    }
    
    // 更新学习进度
    updateProgress(subjectId, lessonId, score, timeSpent) {
        this.learningProgress.totalStudyTime += timeSpent;
        
        const progressEntry = {
            subjectId,
            lessonId,
            score,
            timeSpent,
            completedAt: new Date()
        };
        
        this.learningProgress.completedLessons.push(progressEntry);
        this.updatedAt = new Date();
        
        // 更新经验值
        this.profile.experience += Math.floor(score * 10);
        
        // 检查等级提升
        this.checkLevelUp();
    }
    
    // 检查等级提升
    checkLevelUp() {
        const requiredExp = this.profile.level * 1000;
        if (this.profile.experience >= requiredExp) {
            this.profile.level++;
            this.profile.experience -= requiredExp;
            return true;
        }
        return false;
    }
}

// 教学资源实体模型
class TeachingResourceEntity {
    constructor(data) {
        this.id = data.id;
        this.title = data.title;
        this.description = data.description;
        this.subject = data.subject; // 学科分类
        this.type = data.type; // 资源类型: '3d-model', '2d-animation', 'video', 'text', 'interactive'
        this.difficulty = data.difficulty; // 难度等级: 'beginner', 'intermediate', 'advanced'
        this.tags = data.tags || [];
        this.content = {
            url: data.contentUrl,
            format: data.format,
            size: data.size,
            duration: data.duration,
            metadata: data.metadata || {}
        };
        this.educational = {
            learningObjectives: data.learningObjectives || [],
            prerequisites: data.prerequisites || [],
            targetAudience: data.targetAudience || [],
            assessmentCriteria: data.assessmentCriteria || []
        };
        this.technical = {
            renderingRequirements: data.renderingRequirements || {},
            interactionCapabilities: data.interactionCapabilities || [],
            compatibilityInfo: data.compatibilityInfo || {}
        };
        this.usage = {
            viewCount: 0,
            downloadCount: 0,
            rating: 0,
            reviews: [],
            lastAccessed: null
        };
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
    }
    
    // 更新使用统计
    updateUsageStats(action, userId) {
        switch (action) {
            case 'view':
                this.usage.viewCount++;
                break;
            case 'download':
                this.usage.downloadCount++;
                break;
        }
        this.usage.lastAccessed = new Date();
        this.updatedAt = new Date();
    }
    
    // 添加评价
    addReview(userId, rating, comment) {
        const review = {
            userId,
            rating,
            comment,
            createdAt: new Date()
        };
        
        this.usage.reviews.push(review);
        
        // 重新计算平均评分
        const totalRating = this.usage.reviews.reduce((sum, review) => sum + review.rating, 0);
        this.usage.rating = totalRating / this.usage.reviews.length;
        
        this.updatedAt = new Date();
    }
}

// AI对话实体模型
class AIConversationEntity {
    constructor(data) {
        this.id = data.id;
        this.userId = data.userId;
        this.subject = data.subject;
        this.sessionId = data.sessionId;
        this.messages = data.messages || [];
        this.context = {
            currentTopic: data.currentTopic,
            learningGoal: data.learningGoal,
            userLevel: data.userLevel,
            previousSessions: data.previousSessions || []
        };
        this.metadata = {
            totalMessages: 0,
            averageResponseTime: 0,
            satisfactionScore: 0,
            topics: [],
            keywords: []
        };
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
    }
    
    // 添加消息
    addMessage(role, content, metadata = {}) {
        const message = {
            id: this.generateMessageId(),
            role, // 'user' | 'assistant' | 'system'
            content,
            timestamp: new Date(),
            metadata: {
                responseTime: metadata.responseTime,
                confidence: metadata.confidence,
                sources: metadata.sources || [],
                relatedResources: metadata.relatedResources || []
            }
        };
        
        this.messages.push(message);
        this.metadata.totalMessages++;
        this.updatedAt = new Date();
        
        // 更新平均响应时间
        if (metadata.responseTime) {
            const totalResponseTime = this.metadata.averageResponseTime * (this.metadata.totalMessages - 1) + metadata.responseTime;
            this.metadata.averageResponseTime = totalResponseTime / this.metadata.totalMessages;
        }
        
        return message;
    }
    
    // 提取对话主题
    extractTopics() {
        const allContent = this.messages
            .filter(msg => msg.role === 'user')
            .map(msg => msg.content)
            .join(' ');
        
        // 简单的关键词提取（实际应用中可以使用更复杂的NLP算法）
        const keywords = allContent
            .toLowerCase()
            .split(/\s+/)
            .filter(word => word.length > 3)
            .reduce((acc, word) => {
                acc[word] = (acc[word] || 0) + 1;
                return acc;
            }, {});
        
        this.metadata.keywords = Object.entries(keywords)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10)
            .map(([word]) => word);
    }
    
    generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
```

### 🔄 数据流架构

#### 📊 数据流管理器

```javascript
// 数据流管理器
class DataFlowManager {
    constructor() {
        this.streams = new Map();
        this.processors = new Map();
        this.subscribers = new Map();
    }
    
    // 创建数据流
    createStream(streamId, config = {}) {
        const stream = {
            id: streamId,
            type: config.type || 'realtime',
            buffer: [],
            maxBufferSize: config.maxBufferSize || 1000,
            processors: [],
            subscribers: [],
            isActive: false,
            metadata: {
                createdAt: new Date(),
                totalMessages: 0,
                lastActivity: null
            }
        };
        
        this.streams.set(streamId, stream);
        return stream;
    }
    
    // 添加数据处理器
    addProcessor(streamId, processor) {
        const stream = this.streams.get(streamId);
        if (stream) {
            stream.processors.push(processor);
        }
    }
    
    // 发送数据到流
    async sendToStream(streamId, data) {
        const stream = this.streams.get(streamId);
        if (!stream) return;
        
        // 处理数据
        let processedData = data;
        for (const processor of stream.processors) {
            processedData = await processor.process(processedData);
        }
        
        // 添加到缓冲区
        stream.buffer.push({
            data: processedData,
            timestamp: new Date(),
            id: this.generateDataId()
        });
        
        // 限制缓冲区大小
        if (stream.buffer.length > stream.maxBufferSize) {
            stream.buffer.shift();
        }
        
        // 通知订阅者
        stream.subscribers.forEach(subscriber => {
            try {
                subscriber.onData(processedData);
            } catch (error) {
                console.error(`数据流订阅者处理失败: ${error.message}`);
            }
        });
        
        // 更新元数据
        stream.metadata.totalMessages++;
        stream.metadata.lastActivity = new Date();
    }
    
    // 订阅数据流
    subscribe(streamId, subscriber) {
        const stream = this.streams.get(streamId);
        if (stream) {
            stream.subscribers.push(subscriber);
        }
    }
    
    generateDataId() {
        return `data_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// 数据处理器接口
class DataProcessor {
    constructor(name, processFn) {
        this.name = name;
        this.processFn = processFn;
        this.metrics = {
            processedCount: 0,
            errorCount: 0,
            averageProcessingTime: 0
        };
    }
    
    async process(data) {
        const startTime = performance.now();
        
        try {
            const result = await this.processFn(data);
            this.recordSuccess(startTime);
            return result;
        } catch (error) {
            this.recordError(startTime, error);
            throw error;
        }
    }
    
    recordSuccess(startTime) {
        const processingTime = performance.now() - startTime;
        this.metrics.processedCount++;
        
        const totalTime = this.metrics.averageProcessingTime * (this.metrics.processedCount - 1) + processingTime;
        this.metrics.averageProcessingTime = totalTime / this.metrics.processedCount;
    }
    
    recordError(startTime, error) {
        this.metrics.errorCount++;
        console.error(`数据处理器 ${this.name} 处理失败: ${error.message}`);
    }
}
```

---

## 🤖 AI算法架构

### 🧠 AI服务架构

#### 🎯 多模态AI分析引擎

```javascript
// 多模态AI分析引擎
class MultimodalAIEngine {
    constructor() {
        this.models = new Map();
        this.processors = new Map();
        this.cache = new Map();
        this.config = {
            maxCacheSize: 1000,
            cacheTTL: 300000, // 5分钟
            batchSize: 10,
            timeout: 30000
        };
        
        this.initializeModels();
    }
    
    // 初始化AI模型
    initializeModels() {
        // 文本分析模型
        this.models.set('text-analysis', {
            type: 'nlp',
            capabilities: ['sentiment', 'keywords', 'entities', 'classification'],
            endpoint: 'https://api.siliconflow.cn/v1/chat/completions',
            model: 'Qwen/QwQ-32B'
        });
        
        // 图像识别模型
        this.models.set('image-recognition', {
            type: 'computer-vision',
            capabilities: ['object-detection', 'scene-classification', 'ocr'],
            endpoint: 'https://api.example.com/vision/v1',
            model: 'vision-transformer-large'
        });
        
        // 语音处理模型
        this.models.set('speech-processing', {
            type: 'audio',
            capabilities: ['speech-to-text', 'text-to-speech', 'emotion-detection'],
            endpoint: 'https://api.example.com/speech/v1',
            model: 'whisper-large'
        });
        
        // 多模态融合模型
        this.models.set('multimodal-fusion', {
            type: 'multimodal',
            capabilities: ['cross-modal-understanding', 'content-generation'],
            endpoint: 'https://api.example.com/multimodal/v1',
            model: 'clip-large'
        });
    }
    
    // 智能内容分析
    async analyzeContent(content, options = {}) {
        const analysisId = this.generateAnalysisId();
        const startTime = performance.now();
        
        try {
            // 检查缓存
            const cacheKey = this.generateCacheKey(content, options);
            if (this.cache.has(cacheKey)) {
                const cached = this.cache.get(cacheKey);
                if (Date.now() - cached.timestamp < this.config.cacheTTL) {
                    return cached.result;
                }
            }
            
            // 确定内容类型
            const contentType = this.detectContentType(content);
            
            // 选择合适的分析策略
            const analysisStrategy = this.selectAnalysisStrategy(contentType, options);
            
            // 执行分析
            const result = await this.executeAnalysis(content, analysisStrategy, options);
            
            // 缓存结果
            this.cache.set(cacheKey, {
                result,
                timestamp: Date.now()
            });
            
            // 清理过期缓存
            this.cleanupCache();
            
            return {
                ...result,
                analysisId,
                processingTime: performance.now() - startTime,
                contentType,
                strategy: analysisStrategy.name
            };
            
        } catch (error) {
            console.error(`AI内容分析失败: ${error.message}`);
            throw new Error(`分析失败: ${error.message}`);
        }
    }
    
    // 检测内容类型
    detectContentType(content) {
        if (typeof content === 'string') {
            return 'text';
        } else if (content instanceof File) {
            if (content.type.startsWith('image/')) {
                return 'image';
            } else if (content.type.startsWith('audio/')) {
                return 'audio';
            } else if (content.type.startsWith('video/')) {
                return 'video';
            }
        } else if (content instanceof ArrayBuffer) {
            return 'binary';
        } else if (Array.isArray(content)) {
            return 'multimodal';
        }
        return 'unknown';
    }
    
    // 选择分析策略
    selectAnalysisStrategy(contentType, options) {
        const strategies = {
            text: {
                name: 'text-comprehensive',
                models: ['text-analysis'],
                pipeline: [
                    'preprocess',
                    'tokenize',
                    'analyze-sentiment',
                    'extract-keywords',
                    'classify-content',
                    'generate-summary'
                ]
            },
            image: {
                name: 'image-comprehensive',
                models: ['image-recognition'],
                pipeline: [
                    'preprocess',
                    'detect-objects',
                    'classify-scene',
                    'extract-text',
                    'analyze-composition'
                ]
            },
            audio: {
                name: 'audio-comprehensive',
                models: ['speech-processing'],
                pipeline: [
                    'preprocess',
                    'speech-to-text',
                    'analyze-emotion',
                    'extract-features'
                ]
            },
            multimodal: {
                name: 'multimodal-comprehensive',
                models: ['text-analysis', 'image-recognition', 'multimodal-fusion'],
                pipeline: [
                    'separate-modalities',
                    'analyze-individual',
                    'fuse-results',
                    'generate-insights'
                ]
            }
        };
        
        return strategies[contentType] || strategies.text;
    }
    
    // 执行分析
    async executeAnalysis(content, strategy, options) {
        const results = {};
        
        for (const step of strategy.pipeline) {
            const processor = this.processors.get(step);
            if (processor) {
                try {
                    const stepResult = await processor.process(content, results, options);
                    results[step] = stepResult;
                } catch (error) {
                    console.warn(`分析步骤 ${step} 失败: ${error.message}`);
                    results[step] = { error: error.message };
                }
            }
        }
        
        return {
            strategy: strategy.name,
            results,
            confidence: this.calculateConfidence(results),
            recommendations: this.generateRecommendations(results)
        };
    }
    
    // 计算置信度
    calculateConfidence(results) {
        const confidenceScores = Object.values(results)
            .filter(result => result.confidence !== undefined)
            .map(result => result.confidence);
        
        if (confidenceScores.length === 0) return 0.5;
        
        return confidenceScores.reduce((sum, score) => sum + score, 0) / confidenceScores.length;
    }
    
    // 生成推荐
    generateRecommendations(results) {
        const recommendations = [];
        
        // 基于分析结果生成个性化推荐
        if (results['classify-content']?.category) {
            const category = results['classify-content'].category;
            recommendations.push({
                type: 'related-content',
                title: `探索更多${category}相关内容`,
                reason: '基于内容分类分析',
                priority: 0.8
            });
        }
        
        if (results['extract-keywords']?.keywords) {
            const keywords = results['extract-keywords'].keywords.slice(0, 3);
            recommendations.push({
                type: 'keyword-expansion',
                title: `深入学习: ${keywords.join(', ')}`,
                reason: '基于关键词分析',
                priority: 0.7
            });
        }
        
        return recommendations.sort((a, b) => b.priority - a.priority);
    }
    
    generateAnalysisId() {
        return `analysis_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    generateCacheKey(content, options) {
        const contentHash = this.hashContent(content);
        const optionsHash = this.hashContent(JSON.stringify(options));
        return `${contentHash}_${optionsHash}`;
    }
    
    hashContent(content) {
        // 简单的哈希函数（实际应用中应使用更强的哈希算法）
        let hash = 0;
        const str = typeof content === 'string' ? content : JSON.stringify(content);
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转换为32位整数
        }
        return hash.toString(36);
    }
    
    cleanupCache() {
        if (this.cache.size > this.config.maxCacheSize) {
            const entries = Array.from(this.cache.entries());
            entries.sort(([,a], [,b]) => a.timestamp - b.timestamp);
            
            const toDelete = entries.slice(0, Math.floor(this.config.maxCacheSize * 0.2));
            toDelete.forEach(([key]) => this.cache.delete(key));
        }
    }
}
```

---

## 🎮 3D渲染引擎架构

### 🚀 Three.js渲染管线设计

#### 🎨 渲染管线架构

```javascript
// 3D渲染引擎核心架构
class Advanced3DRenderingEngine {
    constructor(config = {}) {
        this.config = {
            antialias: config.antialias !== false,
            shadows: config.shadows !== false,
            postProcessing: config.postProcessing !== false,
            adaptiveQuality: config.adaptiveQuality !== false,
            maxFPS: config.maxFPS || 60,
            ...config
        };

        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null; // 后处理合成器

        this.renderTargets = new Map();
        this.materials = new Map();
        this.geometries = new Map();
        this.textures = new Map();

        this.performanceMonitor = new RenderingPerformanceMonitor();
        this.qualityController = new AdaptiveQualityController();

        this.init();
    }

    // 初始化渲染引擎
    init() {
        this.createScene();
        this.createCamera();
        this.createRenderer();
        this.setupLighting();
        this.setupPostProcessing();
        this.startRenderLoop();
    }

    // 创建场景
    createScene() {
        this.scene = new THREE.Scene();

        // 设置场景背景
        this.scene.background = new THREE.Color(0x000011);

        // 添加雾效
        this.scene.fog = new THREE.Fog(0x000011, 10, 100);

        // 场景图优化
        this.scene.matrixAutoUpdate = false;
    }

    // 创建相机系统
    createCamera() {
        this.camera = new THREE.PerspectiveCamera(
            75, // FOV
            window.innerWidth / window.innerHeight, // 宽高比
            0.1, // 近裁剪面
            1000 // 远裁剪面
        );

        this.camera.position.set(0, 5, 10);
        this.camera.lookAt(0, 0, 0);

        // 相机控制器
        this.cameraController = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.cameraController.enableDamping = true;
        this.cameraController.dampingFactor = 0.05;
    }

    // 创建渲染器
    createRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            antialias: this.config.antialias,
            alpha: true,
            powerPreference: "high-performance"
        });

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // 启用阴影
        if (this.config.shadows) {
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }

        // 色彩管理
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;

        // 性能优化
        this.renderer.info.autoReset = false;
    }

    // 设置光照系统
    setupLighting() {
        // 环境光
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        this.scene.add(ambientLight);

        // 主光源
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;

        // 阴影优化
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;

        this.scene.add(directionalLight);

        // 补光
        const fillLight = new THREE.DirectionalLight(0x4080ff, 0.3);
        fillLight.position.set(-10, 5, -5);
        this.scene.add(fillLight);
    }

    // 设置后处理
    setupPostProcessing() {
        if (!this.config.postProcessing) return;

        this.composer = new THREE.EffectComposer(this.renderer);

        // 渲染通道
        const renderPass = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        // FXAA抗锯齿
        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.x = 1 / window.innerWidth;
        fxaaPass.material.uniforms['resolution'].value.y = 1 / window.innerHeight;
        this.composer.addPass(fxaaPass);

        // 辉光效果
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // 强度
            0.4, // 半径
            0.85 // 阈值
        );
        this.composer.addPass(bloomPass);
    }

    // 渲染循环
    startRenderLoop() {
        const animate = () => {
            requestAnimationFrame(animate);

            // 性能监控
            this.performanceMonitor.begin();

            // 更新控制器
            this.cameraController.update();

            // 自适应质量控制
            if (this.config.adaptiveQuality) {
                this.qualityController.update(this.performanceMonitor.getFPS());
            }

            // 渲染
            if (this.composer) {
                this.composer.render();
            } else {
                this.renderer.render(this.scene, this.camera);
            }

            // 性能监控结束
            this.performanceMonitor.end();

            // 清理渲染信息
            this.renderer.info.reset();
        };

        animate();
    }
}

// 性能监控器
class RenderingPerformanceMonitor {
    constructor() {
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 60;
        this.frameTime = 16.67;
        this.history = [];
        this.maxHistorySize = 60;
    }

    begin() {
        this.startTime = performance.now();
    }

    end() {
        const endTime = performance.now();
        this.frameTime = endTime - this.startTime;
        this.frameCount++;

        // 每秒计算一次FPS
        if (endTime - this.lastTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastTime = endTime;

            // 记录历史
            this.history.push({
                fps: this.fps,
                frameTime: this.frameTime,
                timestamp: endTime
            });

            if (this.history.length > this.maxHistorySize) {
                this.history.shift();
            }
        }
    }

    getFPS() {
        return this.fps;
    }

    getFrameTime() {
        return this.frameTime;
    }

    getAverageFPS() {
        if (this.history.length === 0) return this.fps;

        const sum = this.history.reduce((acc, frame) => acc + frame.fps, 0);
        return sum / this.history.length;
    }
}

// 自适应质量控制器
class AdaptiveQualityController {
    constructor() {
        this.targetFPS = 60;
        this.minFPS = 30;
        this.qualityLevel = 1.0; // 0.0 - 1.0
        this.adjustmentThreshold = 5; // FPS差异阈值
        this.adjustmentRate = 0.1; // 调整速率
    }

    update(currentFPS) {
        const fpsDiff = this.targetFPS - currentFPS;

        if (Math.abs(fpsDiff) > this.adjustmentThreshold) {
            if (fpsDiff > 0 && this.qualityLevel < 1.0) {
                // FPS低于目标，降低质量
                this.qualityLevel = Math.max(0.1, this.qualityLevel - this.adjustmentRate);
                this.applyQualitySettings();
            } else if (fpsDiff < 0 && this.qualityLevel > 0.1) {
                // FPS高于目标，提高质量
                this.qualityLevel = Math.min(1.0, this.qualityLevel + this.adjustmentRate);
                this.applyQualitySettings();
            }
        }
    }

    applyQualitySettings() {
        // 根据质量等级调整渲染设置
        const pixelRatio = Math.min(window.devicePixelRatio, 1 + this.qualityLevel);

        // 调整渲染分辨率
        const canvas = document.querySelector('canvas');
        if (canvas) {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            canvas.width = width * pixelRatio * this.qualityLevel;
            canvas.height = height * pixelRatio * this.qualityLevel;
        }

        console.log(`质量等级调整为: ${(this.qualityLevel * 100).toFixed(1)}%`);
    }
}
```

### 🎯 学科专用渲染器

#### 🧬 生物学科3D渲染器

```javascript
// 生物学科专用3D渲染器
class BiologyRenderer extends Advanced3DRenderingEngine {
    constructor(config) {
        super(config);
        this.moleculeLibrary = new Map();
        this.cellStructures = new Map();
        this.animationMixers = [];

        this.initBiologySpecific();
    }

    initBiologySpecific() {
        // 加载生物学专用材质
        this.loadBiologyMaterials();

        // 设置生物学场景环境
        this.setupBiologyEnvironment();

        // 初始化分子库
        this.initMoleculeLibrary();
    }

    loadBiologyMaterials() {
        // DNA材质
        this.materials.set('dna', new THREE.MeshPhongMaterial({
            color: 0x4a90e2,
            transparent: true,
            opacity: 0.8,
            shininess: 100
        }));

        // 蛋白质材质
        this.materials.set('protein', new THREE.MeshLambertMaterial({
            color: 0xe74c3c,
            transparent: true,
            opacity: 0.9
        }));

        // 细胞膜材质
        this.materials.set('membrane', new THREE.MeshPhysicalMaterial({
            color: 0x95a5a6,
            transparent: true,
            opacity: 0.3,
            transmission: 0.7,
            roughness: 0.1
        }));
    }

    // 创建DNA双螺旋结构
    createDNAHelix(config = {}) {
        const group = new THREE.Group();
        const radius = config.radius || 2;
        const height = config.height || 10;
        const turns = config.turns || 3;
        const segments = config.segments || 100;

        // 创建螺旋路径
        const curve1 = new THREE.CatmullRomCurve3(this.generateHelixPoints(radius, height, turns, segments, 0));
        const curve2 = new THREE.CatmullRomCurve3(this.generateHelixPoints(radius, height, turns, segments, Math.PI));

        // 创建螺旋几何体
        const tubeGeometry1 = new THREE.TubeGeometry(curve1, segments, 0.1, 8, false);
        const tubeGeometry2 = new THREE.TubeGeometry(curve2, segments, 0.1, 8, false);

        const dnaMaterial = this.materials.get('dna');
        const helix1 = new THREE.Mesh(tubeGeometry1, dnaMaterial);
        const helix2 = new THREE.Mesh(tubeGeometry2, dnaMaterial);

        group.add(helix1, helix2);

        // 添加碱基对连接
        this.addBasePairs(group, curve1, curve2, segments);

        return group;
    }

    generateHelixPoints(radius, height, turns, segments, phase) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const angle = turns * 2 * Math.PI * t + phase;
            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);
            const y = height * (t - 0.5);
            points.push(new THREE.Vector3(x, y, z));
        }
        return points;
    }

    addBasePairs(group, curve1, curve2, segments) {
        const basePairGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
        const basePairMaterial = new THREE.MeshPhongMaterial({ color: 0xf39c12 });

        for (let i = 0; i < segments; i += 5) {
            const t = i / segments;
            const point1 = curve1.getPoint(t);
            const point2 = curve2.getPoint(t);

            const basePair = new THREE.Mesh(basePairGeometry, basePairMaterial);
            basePair.position.copy(point1.clone().add(point2).multiplyScalar(0.5));
            basePair.lookAt(point2);
            basePair.rotateX(Math.PI / 2);
            basePair.scale.y = point1.distanceTo(point2);

            group.add(basePair);
        }
    }

    // 创建细胞结构
    createCellStructure(type, config = {}) {
        const cellGroup = new THREE.Group();

        switch (type) {
            case 'animal':
                return this.createAnimalCell(config);
            case 'plant':
                return this.createPlantCell(config);
            case 'bacteria':
                return this.createBacteriaCell(config);
            default:
                return this.createGenericCell(config);
        }
    }

    createAnimalCell(config) {
        const cellGroup = new THREE.Group();

        // 细胞膜
        const membraneGeometry = new THREE.SphereGeometry(5, 32, 32);
        const membrane = new THREE.Mesh(membraneGeometry, this.materials.get('membrane'));
        cellGroup.add(membrane);

        // 细胞核
        const nucleusGeometry = new THREE.SphereGeometry(2, 16, 16);
        const nucleusMaterial = new THREE.MeshPhongMaterial({ color: 0x8e44ad });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        nucleus.position.set(0, 0, 0);
        cellGroup.add(nucleus);

        // 线粒体
        for (let i = 0; i < 8; i++) {
            const mitochondria = this.createMitochondria();
            const angle = (i / 8) * Math.PI * 2;
            const radius = 3;
            mitochondria.position.set(
                Math.cos(angle) * radius,
                (Math.random() - 0.5) * 2,
                Math.sin(angle) * radius
            );
            cellGroup.add(mitochondria);
        }

        return cellGroup;
    }

    createMitochondria() {
        const group = new THREE.Group();

        // 外膜
        const outerGeometry = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
        const outerMaterial = new THREE.MeshPhongMaterial({
            color: 0xe67e22,
            transparent: true,
            opacity: 0.7
        });
        const outer = new THREE.Mesh(outerGeometry, outerMaterial);
        group.add(outer);

        // 内膜褶皱
        for (let i = 0; i < 5; i++) {
            const cristaGeometry = new THREE.PlaneGeometry(0.4, 0.8);
            const cristaMaterial = new THREE.MeshPhongMaterial({
                color: 0xd35400,
                side: THREE.DoubleSide
            });
            const crista = new THREE.Mesh(cristaGeometry, cristaMaterial);
            crista.position.x = (i - 2) * 0.2;
            crista.rotation.y = Math.PI / 2;
            group.add(crista);
        }

        return group;
    }
}
```

---

## 📱 用户界面设计规范

### 🎨 设计系统架构

#### 🌈 色彩系统设计

```javascript
// 十大学科色彩系统
const SubjectColorSystem = {
    // 学科主色调
    subjects: {
        computer: {
            primary: '#00d4ff',      // 科技蓝
            secondary: '#0099cc',    // 深蓝
            accent: '#66e6ff',       // 亮蓝
            background: '#001122',   // 深蓝背景
            text: '#ffffff'          // 白色文字
        },
        mathematics: {
            primary: '#ff6b35',      // 数学橙
            secondary: '#cc5429',    // 深橙
            accent: '#ff8c66',       // 亮橙
            background: '#1a0f0a',   // 深橙背景
            text: '#ffffff'
        },
        physics: {
            primary: '#8a2be2',      // 物理紫
            secondary: '#6a1b9a',    // 深紫
            accent: '#ba68c8',       // 亮紫
            background: '#1a0d1f',   // 深紫背景
            text: '#ffffff'
        },
        chemistry: {
            primary: '#4caf50',      // 化学绿
            secondary: '#388e3c',    // 深绿
            accent: '#81c784',       // 亮绿
            background: '#0d1f0f',   // 深绿背景
            text: '#ffffff'
        },
        biology: {
            primary: '#ff9800',      // 生物橙黄
            secondary: '#f57c00',    // 深橙黄
            accent: '#ffb74d',       // 亮橙黄
            background: '#1f1509',   // 深橙黄背景
            text: '#ffffff'
        },
        geography: {
            primary: '#2196f3',      // 地理蓝
            secondary: '#1976d2',    // 深蓝
            accent: '#64b5f6',       // 亮蓝
            background: '#0a1929',   // 深蓝背景
            text: '#ffffff'
        },
        chinese: {
            primary: '#e91e63',      // 语文红
            secondary: '#c2185b',    // 深红
            accent: '#f06292',       // 亮红
            background: '#1f0a14',   // 深红背景
            text: '#ffffff'
        },
        english: {
            primary: '#9c27b0',      // 英语紫红
            secondary: '#7b1fa2',    // 深紫红
            accent: '#ce93d8',       // 亮紫红
            background: '#1a0d1f',   // 深紫红背景
            text: '#ffffff'
        },
        history: {
            primary: '#795548',      // 历史棕
            secondary: '#5d4037',    // 深棕
            accent: '#a1887f',       // 亮棕
            background: '#1a1611',   // 深棕背景
            text: '#ffffff'
        },
        politics: {
            primary: '#f44336',      // 政治红
            secondary: '#d32f2f',    // 深红
            accent: '#ef5350',       // 亮红
            background: '#1f0a0a',   // 深红背景
            text: '#ffffff'
        }
    },

    // 通用色彩
    common: {
        success: '#4caf50',
        warning: '#ff9800',
        error: '#f44336',
        info: '#2196f3',
        background: {
            primary: '#0a0a24',     // 主背景
            secondary: '#1a1a3e',   // 次背景
            surface: '#2a2a5e',     // 表面
            overlay: 'rgba(0,0,0,0.7)'
        },
        text: {
            primary: '#ffffff',
            secondary: '#b0b0b0',
            disabled: '#666666'
        }
    },

    // 获取学科色彩
    getSubjectColors(subject) {
        return this.subjects[subject] || this.subjects.computer;
    },

    // 生成渐变色
    generateGradient(subject, direction = 'to right') {
        const colors = this.getSubjectColors(subject);
        return `linear-gradient(${direction}, ${colors.primary}, ${colors.secondary})`;
    },

    // 生成发光效果
    generateGlow(subject, intensity = 0.5) {
        const colors = this.getSubjectColors(subject);
        return `0 0 ${20 * intensity}px ${colors.primary}${Math.floor(intensity * 255).toString(16)}`;
    }
};
```

#### 🎭 组件设计系统

```javascript
// UI组件设计系统
class UIComponentSystem {
    constructor() {
        this.components = new Map();
        this.themes = new Map();
        this.animations = new Map();

        this.initializeComponents();
        this.initializeThemes();
        this.initializeAnimations();
    }

    // 初始化组件库
    initializeComponents() {
        // 按钮组件
        this.components.set('button', {
            variants: {
                primary: {
                    background: 'var(--subject-primary)',
                    color: 'var(--subject-text)',
                    border: 'none',
                    borderRadius: '8px',
                    padding: '12px 24px',
                    fontSize: '16px',
                    fontWeight: '600',
                    cursor: 'pointer',
                    transition: 'all 0.3s ease',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.2)',
                    ':hover': {
                        transform: 'translateY(-2px)',
                        boxShadow: '0 6px 20px rgba(0,0,0,0.3)'
                    }
                },
                secondary: {
                    background: 'transparent',
                    color: 'var(--subject-primary)',
                    border: '2px solid var(--subject-primary)',
                    borderRadius: '8px',
                    padding: '10px 22px',
                    fontSize: '16px',
                    fontWeight: '600',
                    cursor: 'pointer',
                    transition: 'all 0.3s ease',
                    ':hover': {
                        background: 'var(--subject-primary)',
                        color: 'var(--subject-text)'
                    }
                },
                ghost: {
                    background: 'rgba(255,255,255,0.1)',
                    color: 'var(--subject-text)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '8px',
                    padding: '12px 24px',
                    fontSize: '16px',
                    fontWeight: '500',
                    cursor: 'pointer',
                    backdropFilter: 'blur(10px)',
                    transition: 'all 0.3s ease',
                    ':hover': {
                        background: 'rgba(255,255,255,0.2)',
                        borderColor: 'rgba(255,255,255,0.4)'
                    }
                }
            }
        });

        // 卡片组件
        this.components.set('card', {
            variants: {
                default: {
                    background: 'rgba(255,255,255,0.05)',
                    border: '1px solid rgba(255,255,255,0.1)',
                    borderRadius: '16px',
                    padding: '24px',
                    backdropFilter: 'blur(20px)',
                    boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
                    transition: 'all 0.3s ease',
                    ':hover': {
                        transform: 'translateY(-4px)',
                        boxShadow: '0 12px 40px rgba(0,0,0,0.4)',
                        borderColor: 'rgba(255,255,255,0.2)'
                    }
                },
                glass: {
                    background: 'rgba(255,255,255,0.08)',
                    border: '1px solid rgba(255,255,255,0.15)',
                    borderRadius: '20px',
                    padding: '32px',
                    backdropFilter: 'blur(25px)',
                    boxShadow: '0 12px 48px rgba(0,0,0,0.2)',
                    position: 'relative',
                    overflow: 'hidden',
                    '::before': {
                        content: '""',
                        position: 'absolute',
                        top: '0',
                        left: '0',
                        right: '0',
                        height: '1px',
                        background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent)'
                    }
                }
            }
        });

        // 输入框组件
        this.components.set('input', {
            variants: {
                default: {
                    background: 'rgba(255,255,255,0.05)',
                    border: '2px solid rgba(255,255,255,0.1)',
                    borderRadius: '12px',
                    padding: '16px 20px',
                    fontSize: '16px',
                    color: 'var(--subject-text)',
                    outline: 'none',
                    transition: 'all 0.3s ease',
                    ':focus': {
                        borderColor: 'var(--subject-primary)',
                        boxShadow: '0 0 0 4px rgba(var(--subject-primary-rgb), 0.2)',
                        background: 'rgba(255,255,255,0.08)'
                    },
                    '::placeholder': {
                        color: 'rgba(255,255,255,0.5)'
                    }
                }
            }
        });
    }

    // 创建组件
    createComponent(type, variant = 'default', props = {}) {
        const componentDef = this.components.get(type);
        if (!componentDef) {
            throw new Error(`未知组件类型: ${type}`);
        }

        const variantStyles = componentDef.variants[variant];
        if (!variantStyles) {
            throw new Error(`未知组件变体: ${type}.${variant}`);
        }

        const element = document.createElement(props.tag || 'div');

        // 应用样式
        Object.entries(variantStyles).forEach(([property, value]) => {
            if (property.startsWith(':') || property.startsWith('::')) {
                // 处理伪类和伪元素
                this.addPseudoStyles(element, property, value);
            } else {
                element.style[property] = value;
            }
        });

        // 应用自定义属性
        Object.entries(props).forEach(([key, value]) => {
            if (key !== 'tag' && key !== 'children') {
                if (key.startsWith('on')) {
                    // 事件处理器
                    const eventName = key.slice(2).toLowerCase();
                    element.addEventListener(eventName, value);
                } else if (key === 'className') {
                    element.className = value;
                } else if (key === 'style') {
                    Object.assign(element.style, value);
                } else {
                    element.setAttribute(key, value);
                }
            }
        });

        // 添加子元素
        if (props.children) {
            if (typeof props.children === 'string') {
                element.textContent = props.children;
            } else if (Array.isArray(props.children)) {
                props.children.forEach(child => {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    } else {
                        element.appendChild(child);
                    }
                });
            } else {
                element.appendChild(props.children);
            }
        }

        return element;
    }

    // 添加伪类样式
    addPseudoStyles(element, pseudo, styles) {
        const className = `component-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        element.classList.add(className);

        const styleSheet = document.styleSheets[0] || this.createStyleSheet();
        const rule = `.${className}${pseudo} { ${this.stylesToCSS(styles)} }`;

        try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
        } catch (error) {
            console.warn('无法插入CSS规则:', rule, error);
        }
    }

    // 样式对象转CSS字符串
    stylesToCSS(styles) {
        return Object.entries(styles)
            .map(([property, value]) => `${this.camelToKebab(property)}: ${value}`)
            .join('; ');
    }

    // 驼峰转短横线
    camelToKebab(str) {
        return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
    }

    // 创建样式表
    createStyleSheet() {
        const style = document.createElement('style');
        document.head.appendChild(style);
        return style.sheet;
    }
}
```

---

*本文档由 @星梦游Xmy 于2025年7月独立编写，详细阐述了十大学科多模态教学资源制作管理系统的软件架构设计和技术实现方案。*

**🌟 用代码构建教育的未来，让技术成为知识传播的桥梁！**
